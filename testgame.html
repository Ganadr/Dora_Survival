<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dora-Survivor: Bio-Warfare</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --text-color: #58a6ff;
            --alert-color: #ff7b72;
            --success-color: #3fb950;
            --border-color: #30363d;
            --panel-bg: #161b22;
            --highlight: #f2cc60;
            --rare: #a371f7;
            --legendary: #ffdd57;

            /* Map palette defaults (overridden per world via body[data-world=...]) */
            --map-wrap-border: #333;
            --map-cell-bg: #0b0f14;
            --map-cell-border: var(--border-color);
            --map-cell-text: #8b949e;
            --map-unknown-opacity: 0.35;
            --map-player-outline: var(--highlight);
            --map-start-border: var(--success-color);
            --map-beacon-border: #58a6ff;
            --map-beacon-glow: rgba(88,166,255,0.35);
            --map-danger-border: var(--alert-color);
            --map-danger-bg: rgba(255,123,114,0.10);
            --map-death-border: #ff3b3b;
            --map-death-bg: rgba(255,59,59,0.16);
        }
        body {
            font-family:
                system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans",
                Ubuntu, Cantarell, "Helvetica Neue", Arial,
                "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            font-size: 14px;
            user-select: none;
            text-rendering: optimizeLegibility;
        }

        /* Per-world map palettes (apply to current world and world-map previews) */
        body[data-world="PLAINS"], .world-map[data-world="PLAINS"] {
            --map-wrap-border: #224a34;
            --map-cell-bg: #0a1410;
            --map-cell-border: #2b5f44;
            --map-cell-text: #9ad6b3;
            --map-beacon-border: #7ee787;
            --map-beacon-glow: rgba(126,231,135,0.35);
            --map-danger-border: #ff7b72;
            --map-danger-bg: rgba(255,123,114,0.10);
            --map-death-border: #ff3b3b;
            --map-death-bg: rgba(255,59,59,0.16);
        }
        body[data-world="JUNGLE"], .world-map[data-world="JUNGLE"] {
            --map-wrap-border: #2d5b2b;
            --map-cell-bg: #08130a;
            --map-cell-border: #356b31;
            --map-cell-text: #9fe6a0;
            --map-beacon-border: #a371f7;
            --map-beacon-glow: rgba(163,113,247,0.35);
            --map-danger-border: #ffb86c;
            --map-danger-bg: rgba(255,184,108,0.11);
            --map-death-border: #ff7b72;
            --map-death-bg: rgba(255,123,114,0.16);
        }
        body[data-world="VOLCANO"], .world-map[data-world="VOLCANO"] {
            --map-wrap-border: #5a2418;
            --map-cell-bg: #140807;
            --map-cell-border: #7a2f1f;
            --map-cell-text: #ffb4a1;
            --map-beacon-border: #ffa657;
            --map-beacon-glow: rgba(255,166,87,0.35);
            --map-danger-border: #ff7b72;
            --map-danger-bg: rgba(255,123,114,0.12);
            --map-death-border: #ff3b3b;
            --map-death-bg: rgba(255,59,59,0.18);
        }
        body[data-world="ICE"], .world-map[data-world="ICE"] {
            --map-wrap-border: #254a63;
            --map-cell-bg: #061018;
            --map-cell-border: #2c5a7b;
            --map-cell-text: #9ddcff;
            --map-beacon-border: #58a6ff;
            --map-beacon-glow: rgba(88,166,255,0.35);
            --map-danger-border: #a371f7;
            --map-danger-bg: rgba(163,113,247,0.12);
            --map-death-border: #ff7b72;
            --map-death-bg: rgba(255,123,114,0.14);
        }
        body[data-world="OCEAN"], .world-map[data-world="OCEAN"] {
            --map-wrap-border: #1d3a5f;
            --map-cell-bg: #050c14;
            --map-cell-border: #254a7a;
            --map-cell-text: #9bbcff;
            --map-beacon-border: #79c0ff;
            --map-beacon-glow: rgba(121,192,255,0.35);
            --map-danger-border: #ff7b72;
            --map-danger-bg: rgba(255,123,114,0.10);
            --map-death-border: #ff3b3b;
            --map-death-bg: rgba(255,59,59,0.16);
        }
        body[data-world="MECH"], .world-map[data-world="MECH"] {
            --map-wrap-border: #4a4f57;
            --map-cell-bg: #0b0f14;
            --map-cell-border: #6e7681;
            --map-cell-text: #c9d1d9;
            --map-beacon-border: #d2a8ff;
            --map-beacon-glow: rgba(210,168,255,0.35);
            --map-danger-border: #ff7b72;
            --map-danger-bg: rgba(255,123,114,0.10);
            --map-death-border: #ff3b3b;
            --map-death-bg: rgba(255,59,59,0.16);
        }
        .container { max-width: 900px; margin: 0 auto; display: flex; flex-direction: column; gap: 10px; }
        
        .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        @media (max-width: 600px) { .dashboard { grid-template-columns: 1fr; } }

        .box { border: 1px solid var(--border-color); background: var(--panel-bg); padding: 15px; border-radius: 6px; position: relative; }
        h2, h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; color: #fff; font-size: 16px; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .stat-val { font-weight: bold; color: #fff; }
        
        .trait-tag { display: inline-block; background: #238636; color: white; padding: 3px 6px; border-radius: 4px; font-size: 11px; margin-right: 4px; margin-bottom: 4px; border: 1px solid rgba(255,255,255,0.2); }
        
        #log-area { height: 200px; overflow-y: auto; font-size: 13px; color: #8b949e; border: 1px solid var(--border-color); padding: 10px; background: #000; }
        .log-new { color: var(--success-color); }
        .log-danger { color: var(--alert-color); }
        .log-success { color: var(--success-color); }
        .log-boss { color: var(--rare); font-weight: bold; }
        
        .enemy-container { display: flex; gap: 8px; margin-top: 10px; overflow-x: auto; padding-bottom: 5px; }
        .enemy-card { 
            border: 2px solid var(--border-color); padding: 10px; min-width: 140px; border-radius: 6px; background: #2a0a0a; 
            cursor: pointer; transition: 0.2s; position: relative;
        }
        .enemy-card:hover { border-color: #8b949e; }
        .enemy-card.selected { border-color: var(--highlight); background: #3e3820; }
        .enemy-card.boss { border-color: var(--rare); background: #2a0e38; box-shadow: 0 0 10px var(--rare); }
        .enemy-card.dead { opacity: 0.3; pointer-events: none; filter: grayscale(100%); }
        .enemy-name { color: var(--alert-color); font-weight: bold; display: block; margin-bottom: 5px;}
        .enemy-hp-bar { height: 4px; background: #555; margin: 5px 0; border-radius: 2px; }
        .enemy-hp-fill { height: 100%; background: var(--alert-color); width: 100%; transition: width 0.3s; }

        .quest-bar-container { background: #222; height: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #555; }
        .quest-bar-fill { background: var(--highlight); height: 100%; width: 0%; transition: width 0.5s; }

        /* Mini-map */
        .map-wrap { margin-top: 10px; border-top: 1px solid var(--map-wrap-border); padding-top: 10px; }
        #mini-map {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin-top: 8px;
            max-width: 150px;
            margin-left: auto;
            margin-right: auto;
        }
        .map-cell {
            aspect-ratio: 1 / 1;
            border-radius: 4px;
            border: 1px solid var(--map-cell-border);
            background: var(--map-cell-bg);
            color: var(--map-cell-text);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
        }
        .map-cell.unknown { opacity: var(--map-unknown-opacity); }
        .map-cell.visited { opacity: 1; }
        .map-cell.player { outline: 2px solid var(--map-player-outline); color: #fff; font-weight: 800; }
        .map-cell.start { border-color: var(--map-start-border); }
        .map-cell.beacon { border-color: var(--map-beacon-border); box-shadow: 0 0 6px var(--map-beacon-glow); }
        .map-cell.zone-danger { border-color: var(--map-danger-border); background: linear-gradient(180deg, var(--map-danger-bg), var(--map-cell-bg)); }
        .map-cell.zone-death { border-color: var(--map-death-border); background: linear-gradient(180deg, var(--map-death-bg), var(--map-cell-bg)); }
        /* legacy (n·∫øu c√≤n code c≈© d√πng class danger) */
        .map-cell.danger { border-color: var(--map-danger-border); background: linear-gradient(180deg, var(--map-danger-bg), var(--map-cell-bg)); }

        /* D-pad movement */
        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            width: min(180px, 100%);
            justify-self: center;
        }
        .dpad button {
            padding: 8px;
            font-size: 14px;
            line-height: 1;
        }
        .btn-mini {
            padding: 4px 8px;
            font-size: 11px;
            width: auto;
        }
        .dpad .center {
            border-color: #9e8c43;
            color: var(--highlight);
        }

        .action-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        button { background: #21262d; color: #c9d1d9; border: 1px solid var(--border-color); padding: 12px; cursor: pointer; border-radius: 4px; font-weight: bold; }
        button:hover { background: #30363d; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-gadget { color: var(--highlight); border-color: #9e8c43; }
        .btn-gadget:hover { background: #3e3820; }
        
        .hidden { display: none !important; }
        
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: var(--panel-bg); border: 2px solid var(--success-color); padding: 20px; width: 85%; max-width: 500px; text-align: center; max-height: 80vh; overflow-y: auto; }
        .evo-option { display: block; width: 100%; margin: 10px 0; padding: 15px; border: 1px solid var(--success-color); background: #0d1117; color: var(--success-color); cursor: pointer; text-align: left; border-radius: 6px; }
        .evo-option[data-mode="replace"] { border: 2px dashed #ff7b72 !important; background: rgba(255, 123, 114, 0.12) !important; }

        /* Mode badges: NEW / UPGRADE / REPLACE (gi√∫p user nh·∫≠n di·ªán ngay) */
        .trait-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 800;
            letter-spacing: 0.4px;
            border: 1px solid rgba(255,255,255,0.12);
            margin-left: 6px;
            vertical-align: middle;
        }
        .trait-badge-new { color: #3fb950; background: rgba(63,185,80,0.12); border-color: rgba(63,185,80,0.35); }
        .trait-badge-upgrade { color: #f2cc60; background: rgba(242,204,96,0.10); border-color: rgba(242,204,96,0.35); }
        .trait-badge-replace { color: #ff7b72; background: rgba(255,123,114,0.10); border-color: rgba(255,123,114,0.35); }
        .evo-option[data-mode="replace"] { outline: 1px dashed rgba(255,123,114,0.55); }
    </style>
</head>
<body>

<div class="container">
    <div class="box" style="text-align: center; border-color: var(--highlight);">
        <h2 style="color: var(--highlight); margin:0;">DORA-SURVIVOR: BIO-WARFARE</h2>
    </div>

    <div class="dashboard">
        <div class="box">
            <h3>üë§ Ng∆∞·ªùi S·ªëng S√≥t</h3>
            <div class="stat-row"><span>HP:</span> <span class="stat-val" id="p-hp">100/100</span></div>
            <div class="stat-row"><span>ATK:</span> <span class="stat-val" id="p-atk">15</span></div>
            <div class="stat-row"><span>DEF:</span> <span class="stat-val" id="p-def">5</span></div>
            <div class="stat-row"><span>SPD:</span> <span class="stat-val" id="p-spd">10</span></div>
            <div style="margin-top:10px; border-top:1px dashed #555; padding-top:5px;">
                <div class="stat-row"><span>üß¨ Gen:</span> <span class="stat-val" id="p-gen">0</span></div>
                <div class="stat-row"><span>üì¶ Kho:</span> <span class="stat-val" id="p-inventory">Th·ªãt: 2, Thu·ªëc: 1</span></div>
            </div>
            
            <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center;">
                <small>ƒê·∫∑c t√≠nh:</small>
                <button data-ui="showTraits" style="padding: 2px 8px; font-size: 11px; width: auto; background: #222; border: 1px solid #555;">üëÅÔ∏è Chi ti·∫øt</button>
            </div>
            <div id="p-traits" style="margin-top: 5px;">Ch∆∞a c√≥ ƒë·∫∑c t√≠nh</div>
        </div>

        <div class="box">
            <h3>üöÄ Nhi·ªám V·ª•: C·ªó M√°y Th·ªùi Gian</h3>
            <div class="stat-row"><span>üåç Th·∫ø gi·ªõi:</span> <span class="stat-val" id="w-name">ƒê·ªìng B·∫±ng Xanh</span></div>
            <div class="stat-row"><span>üìç T·ªça ƒë·ªô:</span> <span class="stat-val" id="p-pos">(0,0)</span></div>
            <div class="stat-row"><span>üìè Kho·∫£ng c√°ch:</span> <span class="stat-val" id="p-dist">0</span></div>
            <div class="stat-row"><span>üß© M·∫£nh t·ªça ƒë·ªô:</span> <span class="stat-val" id="p-frag">0/3</span></div>
            <div class="stat-row"><span>üìÖ T·ªïng ng√†y:</span> <span class="stat-val" id="p-day">1</span></div>
            <div class="quest-bar-container">
                <div class="quest-bar-fill" id="quest-bar"></div>
            </div>
            <p id="next-event" style="font-size: 12px; color: #8b949e; margin-top: 10px;">
                T√≠n hi·ªáu m·∫£nh t·ªça ƒë·ªô ph√°t ra t·ª´ kho·∫£ng c√°ch 5 b∆∞·ªõc ch√¢n.
            </p>
            <button id="btn-portal" class="btn-gadget hidden" data-act="openPortal" style="margin-top:10px;width:100%;">üö™ K√çCH HO·∫†T C·ª¨A (ƒê·ªïi Th·∫ø Gi·ªõi)</button>
            <button id="btn-time-machine" class="btn-gadget hidden" data-act="startTimeMachine" style="margin-top:10px;width:100%;">‚è≥ KH·ªûI ƒê·ªòNG C·ªñ M√ÅY TH·ªúI GIAN</button>
            
            <div id="combat-area" class="hidden" style="margin-top: 10px; border-top: 1px solid #333; padding-top:10px;">
                <small style="color: #ff7b72;">‚ö†Ô∏è ƒêANG GIAO CHI·∫æN! (Ch·ªçn m·ª•c ti√™u)</small>
                <div class="enemy-container" id="e-list"></div>
            </div>

            <div class="map-wrap" id="map-wrap">
                <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
                    <small style="color:#8b949e;">B·∫£n ƒë·ªì c·ª•c b·ªô (5x5)</small>
                    <button class="btn-mini" data-ui="toggleMiniMap" id="btn-toggle-mini-map">·∫®n</button>
                </div>
                <div id="mini-map"></div>
            </div>
        </div>
    </div>

    <div id="log-area">
        <div>> Kh·ªüi ƒë·ªông nh·∫≠t k√Ω sinh t·ªìn...</div>
    </div>

    <div class="box">
        <div id="mode-explore" class="action-grid">
            <div class="dpad">
                <button data-move="ul" title="Ch√©o l√™n tr√°i">‚Üñ</button>
                <button data-move="up" title="L√™n">‚Üë</button>
                <button data-move="ur" title="Ch√©o l√™n ph·∫£i">‚Üó</button>
                <button data-move="left" title="Tr√°i">‚Üê</button>
                <button class="center" data-act="openTeleport" title="C·ª≠a Th·∫ßn K·ª≥">üö™</button>
                <button data-move="right" title="Ph·∫£i">‚Üí</button>
                <button data-move="dl" title="Ch√©o xu·ªëng tr√°i">‚Üô</button>
                <button data-move="down" title="Xu·ªëng">‚Üì</button>
                <button data-move="dr" title="Ch√©o xu·ªëng ph·∫£i">‚Üò</button>
            </div>
            <button data-act="openWorldMap">üó∫Ô∏è B·∫¢N ƒê·ªí T·ªîNG</button>
            <button data-act="rest">‚õ∫ NGH·ªà NG∆†I (H·ªìi m√°u, ƒÇn th·ªãt)</button>
            <button data-act="useMedkit">üß∞ D√ôNG THU·ªêC (H·ªìi m√°u nhanh)</button>
            <button class="btn-gadget" data-act="useTablecloth">üçΩÔ∏è KHƒÇN TR·∫¢I B√ÄN (Gen -> Th·ªãt)</button>
            <button data-act="openEvo" id="btn-evo" style="grid-column: span 2; border-color: #3fb950; color: #3fb950;">üß¨ D√ôNG S√öNG TI·∫æN H√ìA (50 Gen)</button>
        </div>

        <div id="mode-combat" class="action-grid hidden">
            <button data-perform="basic">‚öîÔ∏è T·∫§N C√îNG TH∆Ø·ªúNG</button>
            <button class="btn-gadget" data-perform="air_cannon">üí• ƒê·∫°i B√°c Kh√¥ng Kh√≠(DMG Cao)</button>
            <button class="btn-gadget" data-perform="dictator_switch">‚ò†Ô∏è C√¥ng T·∫Øc ƒê·ªôc T√†i(X√≥a S·ªï - No Loot)</button>
            <button class="btn-gadget" data-perform="evo_gun_enemy">üî´ S√∫ng Ti·∫øn H√≥a (Debuff/X√≥a trait)</button>
            <button class="btn-gadget" data-perform="counter_mantle">üõë KhƒÉn Cho√†ng A-l√™-h·∫•p (Ch·∫∑n)</button>
            <button class="btn-gadget" data-perform="anywhere_door">üö™ C·ª≠a Th·∫ßn K·ª≥ (Ch·∫°y)</button>
            <button data-perform="use_medkit">üß∞ D√ôNG THU·ªêC </button>
        </div>
    </div>
</div>

<div id="modal-overlay" class="hidden">
    <div class="modal-content">
        <h3 id="modal-title" style="color: #3fb950;">TH√îNG B√ÅO</h3>
        <p id="modal-desc" style="color: #8b949e; font-size: 13px;">N·ªôi dung</p>
        <div id="modal-body"></div>
        <button id="btn-close-modal" style="margin-top:20px; width:100%;">ƒê√≥ng</button>
    </div>
</div>

<script>
    
    /* --- DATA: SINH H·ªåC --- */
    const PARTS_DB = {
        ATK: [
            { name: "Vu·ªët", tag: "MELEE" }, { name: "Nanh", tag: "DRAIN" }, { name: "Gai", tag: "THORNS" }, 
            { name: "ƒêu√¥i", tag: "MELEE" }, { name: "S·ª´ng", tag: "MELEE" }, { name: "X√∫c Tu", tag: "MELEE" }
        ],
        DEF: [
            { name: "Da", tag: "SKIN" }, { name: "V·ªè", tag: "ARMOR" }, { name: "X∆∞∆°ng", tag: "SKELETON" }, { name: "V·∫£y", tag: "ARMOR" }
        ],
        HP:  [
            { name: "Tim", tag: "CORE" }, { name: "M√°u", tag: "FLUID" }, { name: "T·∫ø B√†o", tag: "CELL" }
        ],
        SPD: [
            { name: "C√°nh", tag: "FLIGHT" }, { name: "Ch√¢n", tag: "MOVE" }, { name: "M·∫Øt", tag: "SIGHT" }
        ]
    };

    const TIERS_DB = [
        { name: "C∆∞·ªùng Ho√°", mod: 1.0, rare: 1, element: "NONE" }, 
        { name: "G·ªó H√≥a", mod: 1.1, rare: 2, element: "HARD" },
        { name: "L·ª≠a", mod: 1.3, rare: 2, element: "FIRE" },   
        { name: "BƒÉng", mod: 1.3, rare: 2, element: "ICE" },   
        { name: "ƒê·ªôc", mod: 1.2, rare: 2, element: "POISON" }, 
        { name: "Huy·∫øt", mod: 1.4, rare: 3, element: "BLOOD" },
        { name: "Tinh Th·ªÉ", mod: 1.8, rare: 3, element: "HARD" }, 
        { name: "H·∫°t Nh√¢n", mod: 2.2, rare: 4, element: "RADIOACTIVE" }, 
        { name: "H∆∞ Kh√¥ng", mod: 2.5, rare: 4, element: "VOID" },
        { name: "V≈© Tr·ª•", mod: 3.0, rare: 5, element: "COSMIC" }
    ];

    const ENTITIES = ["Zombie", "Chu·ªôt", "Gi√°n", "S√≥i", "Ng∆∞·ªùi M√°y", "C√¢y ƒê·ªôt Bi·∫øn", "Th·∫±n L·∫±n"];
    const BOSS_NAMES = ["Kh·ªïng L·ªì M·ªôt M·∫Øt", "B·∫°ch Tu·ªôc Kh√¥ng Gian", "M√°y Ch√©m R·ªâ S√©t", "S√≥i Alpha ƒê·ªôt Bi·∫øn"];
    const FINAL_BOSS = "VUA H·ª¶Y DI·ªÜT";
    const BODY_PARTS = ["Vu·ªët","Nanh","Gai","ƒêu√¥i","S·ª´ng","X√∫c Tu","Da","V·ªè","X∆∞∆°ng","V·∫£y","Tim","M√°u","T·∫ø B√†o","C√°nh","Ch√¢n","M·∫Øt"];

    // --- C·∫¨P NH·∫¨T: Th√™m Boss v√†o Loot Table ƒë·ªÉ th∆∞·ªüng to h∆°n ---
    const LOOT_TABLE = {
        "Zombie": { meat: 0.8, gen: 10, med: 0.05 },
        "Chu·ªôt":  { meat: 0.7, gen: 5,  med: 0.05 },
        "Gi√°n":   { meat: 0.2, gen: 5,  med: 0.05 },
        "S√≥i":    { meat: 1.0, gen: 15, med: 0.0 },
        "Th·∫±n L·∫±n": { meat: 0.9, gen: 10, med: 0.0 },
        "Ng∆∞·ªùi M√°y": { meat: 0.0, gen: 40, med: 0.1 }, 
        "C√¢y ƒê·ªôt Bi·∫øn": { meat: 0.1, gen: 10, med: 0.4 },
        
        // --- Th√™m BOSS ---
        "Kh·ªïng L·ªì M·ªôt M·∫Øt": { meat: 1.0, gen: 100, med: 0.3 },
        "B·∫°ch Tu·ªôc Kh√¥ng Gian": { meat: 1.0, gen: 120, med: 0.3 },
        "M√°y Ch√©m R·ªâ S√©t": { meat: 0.0, gen: 150, med: 0.3 }, // Nhi·ªÅu Gen
        "S√≥i Alpha ƒê·ªôt Bi·∫øn": { meat: 1.0, gen: 120, med: 0.3 },
        "VUA H·ª¶Y DI·ªÜT": { meat: 1.0, gen: 500, med: 1.0 } // Tr√πm cu·ªëi
    };

    const STEPS_PER_DAY = 10;

    let player = {
        // base stats: ch·ªâ thay ƒë·ªïi b·ªüi "C∆∞·ªùng Ho√°" (c·ªông th·∫≥ng v√†o ch·ªâ s·ªë g·ªëc)
        baseMaxHp: 100, baseAtk: 15, baseDef: 5, baseSpd: 10,
        hp: 100, maxHp: 100, atk: 15, def: 5, spd: 10, regen: 0, 
        genPoints: 0, items: { meat: 3, medkit: 1, energy: 0 }, 
        traits: [], steps: 0, slots: {},
        x: 0, y: 0, worldId: "PLAINS", fragments: 0,
        // l·ªãch t·ªïng ng√†y trong game
        gameDay: 1,
        // boss state
        hasEnteredDeathZone: false,
        bossDefeatedOnce: false,
        bossKills: 0,
        timeMachineStarted: false,
        // legacy fields (tr√°nh crash n·∫øu c√≤n code c≈© g·ªçi)
        days: 1, parts: 0
    };
    BODY_PARTS.forEach(p => player.slots[p] = false);

    let currentEnemies = [];
    let isCountering = false;
    let isBossFight = false;

    const ZONES = [
        { name: "An To√†n", min: 0, max: 2, levelMin: 1, levelMax: 2, loot: "low" },
        { name: "M·∫°o Hi·ªÉm", min: 3, max: 6, levelMin: 3, levelMax: 5, loot: "mid" },
        { name: "Nguy Hi·ªÉm", min: 7, max: 10, levelMin: 6, levelMax: 9, loot: "high" },
        { name: "T·ª≠ Th·∫ßn", min: 11, max: Infinity, levelMin: 10, levelMax: 14, loot: "death" }
    ];
    const BEACON_CFG = {
        minDist: 5,
        minChance: 0.10,
        maxChance: 0.65,
        antiSpamFloor: -0.25,
        pityBoostPerDry: 0.04,
        pityMaxBoost: 0.35,
        forceAfterDry: 10
    };
    const REGEN_COUNTER = {
        blockTurns: 2,
        poison: { mul: 0.5, turns: 2 },
        ice: { mul: 0.7, turns: 1 }
    };
    const WORLD_DB = [
        { id: "PLAINS", name: "ƒê·ªìng B·∫±ng Xanh", passive: {}, enemies: ["Slime","Chu·ªôt","Th·ªè","Zombie"] },
        { id: "JUNGLE", name: "R·ª´ng R·∫≠m ƒê·ªôc", passive: { poisonEverySteps: 10, poisonHp: 5 }, enemies: ["C√¢y ƒê·ªôt Bi·∫øn","R·∫Øn","Ong","Gi√°n","S√≥i"] },
        { id: "VOLCANO", name: "N√∫i L·ª≠a", passive: { healMult: 0.8 }, enemies: ["Golem L·ª≠a","R·ªìng Con","S√≥i","Zombie"] },
        { id: "ICE", name: "BƒÉng Nguy√™n", passive: { spdPenalty: 2 }, enemies: ["S√≥i Tuy·∫øt","Ng∆∞·ªùi Tuy·∫øt","S√≥i","Zombie"] },
        { id: "OCEAN", name: "ƒê√°y ƒê·∫°i D∆∞∆°ng", passive: { atkMult: 0.9 }, enemies: ["C√° M·∫≠p","B·∫°ch Tu·ªôc","B·∫°ch Tu·ªôc Kh√¥ng Gian","Th·∫±n L·∫±n"] },
        { id: "MECH", name: "Th√†nh Ph·ªë M√°y", passive: { disableMeat: true }, enemies: ["Ng∆∞·ªùi M√°y","Cyborg","Robot","Ng∆∞·ªùi M√°y"] }
    ];
    const worlds = {};

    const posKey = (x, y) => `${x},${y}`;
    const manhattan = (x, y) => Math.abs(x) + Math.abs(y);
    function ensureWorldFields(w) {
        // back-compat n·∫øu world c≈© ch∆∞a c√≥ field m·ªõi
        if (!w) return;
        if (w.fragmentsPlaced === undefined) w.fragmentsPlaced = 0;
        if (w.beaconDry === undefined) w.beaconDry = 0;
    }
    const getWorld = () => {
        if (!worlds[player.worldId]) {
            worlds[player.worldId] = { id: player.worldId, data: {}, steps: 0, fragmentsPlaced: 0, beaconDry: 0 };
            worlds[player.worldId].data["0,0"] = { type: "START", visited: true };
        }
        ensureWorldFields(worlds[player.worldId]);
        return worlds[player.worldId];
    };
    const currentWorldDef = () => WORLD_DB.find(w => w.id === player.worldId) || WORLD_DB[0];
    const zoneForDist = (d) => ZONES.find(z => d >= z.min && d <= z.max) || ZONES[0];

    function getTile(x, y) {
        const w = getWorld();
        const k = posKey(x, y);
        if (!w.data[k]) w.data[k] = generateTile(x, y);
        return w.data[k];
    }
    function generateTile(x, y) {
        const d = manhattan(x, y);
        if (d === 0) return { type: "START", visited: true, visitCount: 1, lastVisitDay: 1 };
        const w = getWorld();
        const z = zoneForDist(d);

        // Beacon spawn: ch·ªâ b·∫Øt ƒë·∫ßu t·ª´ dist>=minDist v√† ∆∞u ti√™n khi ch∆∞a ƒë·ªß m·∫£nh
        let type = "FIELD";
        if (d >= BEACON_CFG.minDist && player.fragments < 3) {
            const baseChance = z.name === "Nguy Hi·ªÉm" ? 0.22 : z.name === "T·ª≠ Th·∫ßn" ? 0.28 : 0.16;
            // Anti-spam: c√†ng ƒë·∫∑t nhi·ªÅu beacon, c√†ng gi·∫£m chance; c√†ng c√≥ nhi·ªÅu m·∫£nh, c√†ng gi·∫£m chance
            const antiSpam = Math.max(BEACON_CFG.antiSpamFloor, (w.fragmentsPlaced * -0.02) + (player.fragments * -0.03));
            // Pity: n·∫øu ng∆∞·ªùi ch∆°i qu√° xui (t·∫°o nhi·ªÅu √¥ ƒë·ªß ƒëi·ªÅu ki·ªán m√† kh√¥ng ra beacon) th√¨ tƒÉng d·∫ßn v√† c√≥ "b·∫£o hi·ªÉm"
            const pityBoost = Math.min(BEACON_CFG.pityMaxBoost, nnum(w.beaconDry, 0) * BEACON_CFG.pityBoostPerDry);
            const chance = clamp(baseChance + antiSpam + pityBoost, BEACON_CFG.minChance, BEACON_CFG.maxChance);
            const force = nnum(w.beaconDry, 0) >= BEACON_CFG.forceAfterDry; // b·∫£o hi·ªÉm
            if (force || Math.random() < chance) {
                type = "BEACON";
                w.fragmentsPlaced += 1;
                w.beaconDry = 0;
            } else {
                w.beaconDry = nnum(w.beaconDry, 0) + 1;
            }
        }
        return { type, visited: false, cleared: false, visitCount: 0, lastVisitDay: 0 };
    }

    /* --- UTILITIES --- */
    const $ = (id) => document.getElementById(id);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

    const LOG_CLASS = { danger: "log-danger", new: "log-new", success: "log-success", boss: "log-boss", info: "log-info" };
    const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const pickRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];

    function log(msg, type = "info") {
        const div = $("log-area");
        div.insertAdjacentHTML("beforeend", `<div class="${LOG_CLASS[type] || LOG_CLASS.info}">> ${msg}</div>`);
        div.scrollTop = div.scrollHeight;
    }

    function qualityColor(q){ if(q>=5) return "#ff00aa"; if(q===4) return "#ffdd57"; if(q===3) return "#a371f7"; if(q===2) return "#58a6ff"; return "#3fb950"; }

    function openConfirm({ title = "X√ÅC NH·∫¨N", desc = "", yesText = "ƒê·ªìng √Ω", noText = "H·ªßy", onYes, onNo } = {}) {
        // confirm UI thay cho window.confirm
        window.__confirm = { onYes, onNo };
        const body = `<div style="text-align:left;">
            <div style="color:#8b949e;font-size:12px;margin-bottom:10px;">${desc}</div>
            <div style="display:flex;gap:8px;">
                <button class="evo-option" data-confirm="yes" style="flex:1;border-color:#ff7b72;color:#ff7b72;">${yesText}</button>
                <button class="evo-option" data-confirm="no" style="flex:1;">${noText}</button>
            </div>
        </div>`;
        showModal(title, "", false, body);
        const btn = $("btn-close-modal");
        if (btn) { btn.innerText = "ƒê√≥ng"; btn.onclick = () => { closeModal(); window.__confirm = null; onNo?.(); }; }
    }

    function weightedPick(pairs) {
        // pairs: [{value, weight}]
        const total = pairs.reduce((s, p) => s + p.weight, 0);
        let r = Math.random() * total;
        for (const p of pairs) { r -= p.weight; if (r <= 0) return p.value; }
        return pairs[pairs.length - 1].value;
    }

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const nnum = (v, fallback = 0) => (Number.isFinite(Number(v)) ? Number(v) : fallback);
    const hasPassive = (traits, passive) => (traits || []).some(t => t?.passive === passive);
    const setMaxTurns = (obj, key, turns) => {
        obj[key] = Math.max(nnum(obj[key], 0), turns);
        return obj[key];
    };

    function enemyLootFactor(e) {
        const ts = (e?.traits || []).map(normTrait);
        const maxRare = ts.reduce((m, t) => Math.max(m, Number(t?.rare ?? 1)), 1);
        const avgLv = ts.length ? (ts.reduce((s, t) => s + Number(t?.level ?? 1), 0) / ts.length) : 1;
        const sumPow = ts.reduce((s, t) => s + Number(traitTotalVal(t) ?? 0), 0);
        // m·∫°nh/y·∫øu theo rare + level, c·ªông nh·∫π theo t·ªïng ch·ªâ s·ªë (ƒë·ªÉ qu√°i "kh·ªßng" r∆°i nhi·ªÅu gen h∆°n)
        const rareMul = 1 + (maxRare - 1) * 0.18;      // rare 1..5 => 1.00..1.72
        const lvMul = 1 + (avgLv - 1) * 0.05;          // lv tƒÉng nh·∫π
        const powMul = 1 + clamp(sumPow / 1600, 0, 0.65);
        return clamp(rareMul * lvMul * powMul, 0.85, 2.8);
    }

    function enemyMeatChanceByHp(e, baseChance) {
        const hp = Number(e?.stats?.maxHp ?? e?.stats?.hp ?? 50);
        // qu√°i tr√¢u r∆°i th·ªãt d·ªÖ h∆°n
        const hpMul = clamp(hp / 90, 0.55, 2.0);
        return clamp(baseChance * hpMul, 0, 0.95);
    }

    function rollTraitRare() {
        // rare c√†ng cao c√†ng hi·∫øm (c√¢n b·∫±ng)
        return weightedPick([
            { value: 1, weight: 45 },
            { value: 2, weight: 28 },
            { value: 3, weight: 16 },
            { value: 4, weight: 8 },
            { value: 5, weight: 3 }
        ]);
    }

    function rollEnemyTraitLevel(dist) {
        // y√™u c·∫ßu: 1..x v·ªõi x=distance, nh∆∞ng c√¢n b·∫±ng b·∫±ng c√°ch:
        // - cap ·ªü 12
        // - bias th·∫•p (ƒëa s·ªë lv th·∫•p, th·ªânh tho·∫£ng lv cao)
        const cap = Math.max(1, Math.min(12, Math.floor(dist)));
        const r = Math.random();
        return 1 + Math.floor((r * r) * cap);
    }
    
    function toggleInput(disabled) {
        $$('#mode-combat button').forEach(btn => {
            btn.disabled = disabled;
            btn.style.opacity = disabled ? "0.5" : "1";
            btn.style.cursor = disabled ? "not-allowed" : "pointer";
        });
    }

    function setCombatMode(on) {
        $("mode-explore").classList.toggle("hidden", on);
        $("mode-combat").classList.toggle("hidden", !on);
        $("combat-area").classList.toggle("hidden", !on);
        $("map-wrap")?.classList.toggle("hidden", on);
    }

    let isMiniMapHidden = false;
    function toggleMiniMap() {
        isMiniMapHidden = !isMiniMapHidden;
        const map = $("mini-map");
        const btn = $("btn-toggle-mini-map");
        if (map) map.classList.toggle("hidden", isMiniMapHidden);
        if (btn) btn.innerText = isMiniMapHidden ? "Hi·ªán" : "·∫®n";
    }

    // 1 listener cho to√†n b·ªô UI button (g·ªçn h∆°n onclick r·∫£i r√°c)
    document.addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn) return;
        if (btn.disabled) return;

        if (btn.dataset.ui === "toggleMiniMap") return toggleMiniMap();
        if (btn.dataset.ui === "showTraits") return showTraits();

        if (btn.dataset.move) {
            const d = btn.dataset.move;
            if (d === "up") return move(0, 1);
            if (d === "down") return move(0, -1);
            if (d === "left") return move(-1, 0);
            if (d === "right") return move(1, 0);
            if (d === "ul") return move(-1, 1);
            if (d === "ur") return move(1, 1);
            if (d === "dl") return move(-1, -1);
            if (d === "dr") return move(1, -1);
        }

        const actMap = { rest, useMedkit, useTablecloth, openEvo, openPortal, openTeleport, openWorldMap, startTimeMachine };
        const act = btn.dataset.act;
        if (act && actMap[act]) return actMap[act]();

        const perf = btn.dataset.perform;
        if (perf) return performAction(perf);
    });

    /* --- TRAIT GENERATOR --- */
    function playerBaseForTrait(type) {
        // Trait c·ªßa ng∆∞·ªùi ch∆°i s·∫Ω scale theo base stat (ƒë·ªÉ c∆∞·ªùng ho√° l√†m trait "to" d·∫ßn).
        if (type === "HP") return Math.max(1, Number(player.baseMaxHp || 1));
        if (type === "ATK") return Math.max(1, Number(player.baseAtk || 1));
        if (type === "DEF") return Math.max(1, Number(player.baseDef || 1));
        if (type === "SPD") return Math.max(1, Number(player.baseSpd || 1));
        return 1;
    }

    function baseValFromPlayerBase(type) {
        // Map ƒë·ªÉ gi·ªØ c·∫£m gi√°c g·∫ßn gi·ªëng gi√° tr·ªã ban ƒë·∫ßu:
        // HP: ~20% maxHp, ATK: ~50% atk, DEF: ~100% def, SPD: ~50% spd
        const b = playerBaseForTrait(type);
        if (type === "HP") return Math.max(5, Math.round(b * 0.20));
        if (type === "ATK") return Math.max(2, Math.round(b * 0.50));
        if (type === "DEF") return Math.max(1, Math.round(b * 1.00));
        if (type === "SPD") return Math.max(1, Math.round(b * 0.50));
        return 5;
    }

    function generateSynergyTrait(forceTier = null, opts = {}) {
        const { scaleWithPlayerBase = false } = opts || {};
        const TYPES = ["ATK","DEF","HP","SPD","REGEN"]; 
        let type = TYPES[rand(0, TYPES.length-1)];

        let desc = "", finalVal = 0, passive = null, fullName = "";
        // elementName: invariant b·∫Øt bu·ªôc ph·∫£i c√≥ ƒë·ªÉ map m√†u/ƒë·ªô hi·∫øm ·ªïn ƒë·ªãnh
        let elementName = "";
        let rare = 1;
        // partName: d√πng tr·ª±c ti·∫øp t√™n b·ªô ph·∫≠n 
        let partName = "";

        if (type === "REGEN") {
            let val = 4;
            let rareMod = rand(1, 5);
            finalVal = val * rareMod;
            fullName = "T·∫ø B√†o T√°i Sinh" + (rareMod > 1 ? ` Mk.${rareMod}` : "");
            desc = `H·ªìi ${finalVal} HP/l∆∞·ª£t`;
            elementName = "REGEN";
            rare = Math.min(5, Math.max(1, Math.round(finalVal/4)));
            // REGEN g·∫Øn v·ªõi slot "T·∫ø B√†o"
            partName = "T·∫ø B√†o";
        } else {
            let partList = PARTS_DB[type];
            let part = partList[Math.floor(Math.random() * partList.length)];
            partName = part.name;

            let tierList;
            if (forceTier) {
                tierList = [forceTier];
            } else {
                const chosenRare = rollTraitRare();
                tierList = TIERS_DB.filter(t => t.rare === chosenRare);
                if (tierList.length === 0) tierList = TIERS_DB;
            }
            let prefix = pickRandom(tierList);
            
            // Element lu√¥n ch√≠nh l√† tier.name (v√≠ d·ª•: "C∆∞·ªùng Ho√°", "H·∫°t Nh√¢n", "V≈© Tr·ª•"...)
            elementName = prefix.name;
            rare = prefix.rare;

            let baseVal = (type==="HP"?20 : type==="ATK"?8 : 5);
            if (scaleWithPlayerBase) baseVal = baseValFromPlayerBase(type);
            
            if (prefix.name === "C∆∞·ªùng Ho√°") {
                let bonusPercent = rand(1, 15);
                finalVal = Math.floor(baseVal * (1 + bonusPercent/100));
                if (finalVal <= baseVal) finalVal = baseVal + 1; 
                desc = `${type} +${finalVal} (C∆∞·ªùng ho√° ${bonusPercent}%)`;
            } else {
                finalVal = Math.floor(baseVal * prefix.mod * ((Math.random()*0.4)+0.8));
                desc = `${type} +${finalVal}`;
            }
            finalVal = Math.max(1, finalVal);

            let passiveDesc = "";
            if (prefix.element === "FIRE" && part.tag === "MELEE") { passive = "BURN"; passiveDesc = " (Ch√°y +5 DMG)"; }
            else if (prefix.element === "BLOOD" && part.tag === "DRAIN") { passive = "LIFESTEAL"; passiveDesc = " (H√∫t 20% HP)"; }
            else if (prefix.element === "POISON" && (part.tag === "THORNS" || part.tag === "SKIN")) { passive = "POISON_SKIN"; passiveDesc = " (Ph·∫£n ƒë·ªôc)"; }
            else if (prefix.element === "POISON" && type === "ATK") { passive = "TOXIC_WOUND"; passiveDesc = " (ƒê·ªôc: Y·∫øu t√°i sinh)"; }
            else if (prefix.element === "VOID" && type === "ATK") { passive = "PIERCE"; passiveDesc = " (Xuy√™n 50% Gi√°p)"; }
            else if (prefix.element === "VOID" && part.tag === "THORNS") { passive = "DECAY_WOUND"; passiveDesc = " (V·∫øt th∆∞∆°ng: Ch·∫∑n t√°i sinh)"; }
            else if (prefix.element === "RADIOACTIVE" && part.tag === "CORE") { passive = "REACTOR"; passiveDesc = " (H·ªìi Gen, Tr·ª´ M√°u)"; }
            else if (prefix.element === "ICE" && type === "ATK") { passive = "FROST_BITE"; passiveDesc = " (BƒÉng: Y·∫øu t√°i sinh)"; }
            else if (prefix.element === "ICE" && type === "SPD") { passive = "FREEZE_AURA"; passiveDesc = " (Gi·∫£m T·ªëc ƒê·ªãch)"; }

            fullName = `${part.name} ${prefix.name}`;
            desc += passiveDesc;
        }

        // elementName ph·∫£i lu√¥n c√≥; n·∫øu kh√¥ng c√≥ th√¨ coi l√† l·ªói d·ªØ li·ªáu (kh√¥ng ch·∫•p nh·∫≠n trait "m√π element")
        if (!elementName) {
            throw new Error(`Trait missing element: name="${fullName}", type="${type}"`);
        }
        let color = qualityColor(rare);
        // baseVal: gi√° tr·ªã g·ªëc (Lv.1) d√πng ƒë·ªÉ roll upgrade; val: tƒÉng g·∫ßn nh·∫•t; totalVal: t·ªïng c·ªông d·ªìn th·ª±c t·∫ø
        return { name: fullName, type: type, baseVal: finalVal, val: finalVal, totalVal: finalVal, desc: desc, passive: passive, part: partName, element: elementName, level: 1, state: "ACTIVE", rare: rare, color: color };
    }

    function isSlotOccupied(part) {
        return player.traits.some(t => t.part === part && t.state === "ACTIVE");
    }
    function findTrait(part, element) {
        return player.traits.find(t => t.part === part && t.element === element);
    }
    function normalizeTraitColor(t) {
        if (!t) return t;
        let rare = 1;
        const elementName = t.element;
       
        if (!elementName) {
            console.warn("Trait missing element (cannot normalize color reliably):", t);
            // Gi·ªØ m√†u m·∫∑c ƒë·ªãnh ƒë·ªÉ kh√¥ng ph√° UI, nh∆∞ng ƒë√¢y l√† d·ªØ li·ªáu l·ªói.
            t.rare = 1;
            t.color = qualityColor(1);
            return t;
        }
        // T√¨m tier theo name ho·∫∑c element
        let tier = TIERS_DB.find(x => x.name === elementName || x.element === elementName);
        if (tier) {
            rare = tier.rare;
        } else if (t.type === "REGEN") {
            // REGEN: rare d·ª±a tr√™n "Mk" ban ƒë·∫ßu (baseVal), kh√¥ng d·ª±a tr√™n val (tƒÉng g·∫ßn nh·∫•t) ƒë·ªÉ tr√°nh l·ªách khi up c·∫•p random
            const mkBase = Number(t.baseVal ?? t.val ?? 4);
            rare = Math.min(5, Math.max(1, Math.round(mkBase/4)));
        }
        // Lu√¥n c·∫≠p nh·∫≠t l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o m√†u ƒë√∫ng
        t.rare = rare;
        t.color = qualityColor(rare);
        return t;
    }

    const normTrait = (t) => ensureTraitScalingFields(normalizeTraitColor(t));
    const traitTagsHTML = (traits) => (traits?.length ? traits.map(normTrait).map(traitTagHTML).join("") : "");

    function traitTotalVal(t) {
        const total = Number(t?.totalVal);
        if (Number.isFinite(total)) return total;
        
        const perLevel = Number(t?.val ?? 0);
        const lv = Number(t?.level ?? 1);
        return perLevel * lv;
    }
    function traitText(t) {
        // Chu·∫©n ho√° text hi·ªÉn th·ªã c·ªßa trait ·ªü 1 ch·ªó duy nh·∫•t (g·ªçn v√† tr√°nh g·ªçi l·∫∑p)
        if (!t) return { base: "", inc: "", total: "", title: "" };
        ensureTraitScalingFields(t);
        const lv = Number(t.level ?? 1);
        const baseVal = Number(t.baseVal ?? 0);
        const incVal = Number(t.val ?? 0); // tƒÉng g·∫ßn nh·∫•t
        const totalVal = Number(traitTotalVal(t) ?? 0);

        const fmt = (v) => {
            if (!v) return "";
            if (t.type === "REGEN") return `H·ªìi ${v} HP/l∆∞·ª£t`;
            if (t.type === "HP") return `HP +${v}`;
            return `${t.type} +${v}`;
        };

        const base = baseVal ? `G·ªëc: ${fmt(baseVal)}` : "";
        const inc = incVal ? `TƒÉng g·∫ßn nh·∫•t (Lv.${lv}): ${fmt(incVal)}` : "";
        const total = totalVal ? `T·ªïng (Lv.${lv}): ${fmt(totalVal)}` : "";

        const lines = [];
        if (t.desc) lines.push(String(t.desc));
        if (base) lines.push(base);
        if (inc) lines.push(inc);
        if (total) lines.push(total);
        return { base, inc, total, title: lines.join("&#10;") };
    }

    function ensureTraitScalingFields(t) {
        if (!t) return t;
        // baseVal: gi√° tr·ªã g·ªëc ƒë·ªÉ roll upgrade quanh n√≥
        if (t.baseVal === undefined || t.baseVal === null) {
            t.baseVal = Number(t.val ?? 0);
        }
        // totalVal: t·ªïng c·ªông d·ªìn th·ª±c t·∫ø (ƒë·ªÉ remove/hi·ªÉn th·ªã ƒë√∫ng)
        if (t.totalVal === undefined || t.totalVal === null) {
            const lv = Number(t.level ?? 1);
            const per = Number(t.val ?? 0);
            // Back-compat: tr∆∞·ªõc ƒë√¢y m·ªói c·∫•p c·ªông ƒë√∫ng per (kh√¥ng random)
            t.totalVal = per * lv;
        }
        return t;
    }

    function rollUpgradeIncrement(t) {
        // Roll tƒÉng ch·ªâ s·ªë cho l·∫ßn n√¢ng c·∫•p m·ªõi quanh baseVal.
        // C√≥ th·ªÉ ch·ªânh bi√™n ƒë·ªô t·∫°i ƒë√¢y ƒë·ªÉ game "g·∫Øt" h∆°n / ·ªïn ƒë·ªãnh h∆°n.
        ensureTraitScalingFields(t);
        const base = Math.max(1, Number(t.baseVal ?? 1));
        const minF = 0.75;
        const maxF = 1.35;
        const f = minF + Math.random() * (maxF - minF);
        let inc = Math.max(1, Math.round(base * f));
        // HP th∆∞·ªùng to h∆°n, tr√°nh l√™n qu√° nh·ªè g√¢y c·∫£m gi√°c "fail roll"
        if (t.type === "HP") inc = Math.max(3, inc);
        return inc;
    }

    function traitTagHTML(t, extra = {}) {
        const title = (extra.title ?? traitText(t).title ?? "").replaceAll('"', "&quot;");
        const name = (extra.name ?? t.name ?? "").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
        const color = t.color || '#3fb950';
        const bg = `${color}33`;
        return `<span class="trait-tag" style="border-color: ${color}; background: ${bg}; color: #ffffff;" title="${title}">${name}</span>`;
    }
    function applyTraitStats(t, factor, deltaOverride = null) {
        const delta = (deltaOverride === null || deltaOverride === undefined)
            ? (Number(t?.val ?? 0) * factor)
            : (Number(deltaOverride) * factor);
        if (t.type === "HP") { player.maxHp += delta; player.hp = Math.min(player.hp + delta, player.maxHp); }
        if (t.type === "ATK") player.atk += delta;
        if (t.type === "DEF") player.def += delta;
        if (t.type === "SPD") player.spd += delta;
        if (t.type === "REGEN") player.regen += delta;
    }

    function applyPermanentFortify(t) {
        // "C∆∞·ªùng Ho√°": kh√¥ng l∆∞u v√†o kho gen, kh√¥ng c√≥ Lv, c·ªông th·∫≥ng v√†o ch·ªâ s·ªë g·ªëc (stack)
        ensureTraitScalingFields(t);
        const v = Math.max(1, Math.floor(Number(t.baseVal ?? t.val ?? 0)));
        if (t.type === "HP") {
            player.baseMaxHp += v;
            player.maxHp += v;
            player.hp = Math.min(player.maxHp, player.hp + v);
            log(`üí™ C∆∞·ªùng ho√° vƒ©nh vi·ªÖn: HP +${v}.`, "success");
            return;
        }
        if (t.type === "ATK") { player.baseAtk += v; player.atk += v; log(`üí™ C∆∞·ªùng ho√° vƒ©nh vi·ªÖn: ATK +${v}.`, "success"); return; }
        if (t.type === "DEF") { player.baseDef += v; player.def += v; log(`üí™ C∆∞·ªùng ho√° vƒ©nh vi·ªÖn: DEF +${v}.`, "success"); return; }
        if (t.type === "SPD") { player.baseSpd += v; player.spd += v; log(`üí™ C∆∞·ªùng ho√° vƒ©nh vi·ªÖn: SPD +${v}.`, "success"); return; }
        // fallback
        log(`üí™ C∆∞·ªùng ho√° vƒ©nh vi·ªÖn: +${v}.`, "success");
    }

    /* --- UI UPDATE --- */
    function updateUI() {
        $("p-hp").innerText = `${Math.max(0, player.hp)}/${player.maxHp}`;
        $("p-atk").innerText = playerAtkEff();
        $("p-def").innerText = player.def;
        $("p-spd").innerText = playerSpdEff();
        $("p-gen").innerText = player.genPoints;
        const invParts = [`Th·ªãt: ${player.items.meat}`, `Thu·ªëc: ${player.items.medkit}`];
        if ((player.items.energy || 0) > 0) invParts.push(`NƒÉng l∆∞·ª£ng: ${player.items.energy}`);
        $("p-inventory").innerText = invParts.join(", ");
        
        // ·∫®n "C∆∞·ªùng Ho√°" kh·ªèi kho gen (v√¨ n√≥ ƒë√£ c·ªông v√†o ch·ªâ s·ªë g·ªëc)
        $("p-traits").innerHTML = traitTagsHTML((player.traits || []).filter(t => t?.element !== "C∆∞·ªùng Ho√°")) || "Kh√¥ng";

        updateQuestUI();
        updateMapUI();

        $("btn-evo").disabled = player.genPoints < 50;

        if (player.hp <= 0) {
            toggleInput(true); 
            showModal("B·∫†N ƒê√É T·ª¨ N·∫†N", "Th·∫ø gi·ªõi n√†y qu√° kh·∫Øc nghi·ªát. H√£y th·ª≠ l·∫°i.", true);
        }
    }

    function showTraits() {
        if (player.traits.length === 0) { showModal("H·ªí S∆† GEN", "Ch∆∞a c√≥ ƒë·∫∑c t√≠nh."); return; }
        let html = `<div style="text-align: left;">`;
        (player.traits || []).filter(t => t?.element !== "C∆∞·ªùng Ho√°").map(normTrait).forEach((t) => {
            let st = t.state === "ACTIVE" ? "Hi·ªán" : "·∫®n";
            const tt = traitText(t);
            html += `<div style="border:1px solid var(--border-color);padding:8px;margin-bottom:6px;border-radius:6px;background:#0b0f14;">
                <div style="color:#fff;font-weight:bold">${traitTagHTML(t)} [${t.part}] Lv.${t.level} (${st})</div>
                <div style="font-size:12px;color:#ccc">${t.desc || ""}</div>
                ${tt.base ? `<div style="font-size:12px;color:#8b949e;margin-top:4px;">${tt.base}</div>` : ""}
                ${tt.inc ? `<div style="font-size:12px;color:#8b949e;margin-top:4px;">${tt.inc}</div>` : ""}
                ${tt.total ? `<div style="font-size:12px;color:#fff;margin-top:2px;"><strong>${tt.total}</strong></div>` : ""}
            </div>`;
        });
        html += `</div>`;
        showModal(`H·ªí S∆† GEN (T·ªïng: ${player.traits.length})`, "", false, html);
    }

    /* --- GAME LOOP --- */
    function findLoot() {
        let r = rand(1, 100);
        if (r < 50) { player.items.meat += 2; log("T√¨m th·∫•y 2 Th·ªãt bi·∫øn d·ªã.", "new"); }
        else if (r < 80) { player.genPoints += 25; log("H·∫•p th·ª• ƒë∆∞·ª£c 25 Gen t·ª± do.", "new"); }
        else { player.items.medkit += 1; log("Tuy·ªát v·ªùi! T√¨m th·∫•y 1 H·ªôp C·ª©u Th∆∞∆°ng.", "new"); }
        updateUI();
    }

    /* --- COMBAT SYSTEM --- */
    function rollBossTraitLevel(dist) {
        // Boss trait level: CH·ªà scale theo kho·∫£ng c√°ch (ng√†y ch·ªâ ·∫£nh h∆∞·ªüng t·ªâ l·ªá xu·∫•t hi·ªán).
        // Bias th·∫•p gi·ªëng qu√°i th∆∞·ªùng (ƒëa s·ªë lv th·∫•p, th·ªânh tho·∫£ng lv cao).
        const d = Math.max(0, Math.floor(Number(dist || 0)));
        // Kh√¥ng gi·ªõi h·∫°n c·ª©ng: tr·∫ßn level tƒÉng theo kho·∫£ng c√°ch (cap ~ dist + 2)
        const cap = Math.max(2, d + 2);
        const r = Math.random();
        return 1 + Math.floor((r * r) * cap);
    }

    function startCombat(bossMode) {
        isBossFight = bossMode; currentEnemies = []; isCountering = false;
        const dist = manhattan(player.x, player.y);
        const z = zoneForDist(dist);

        // Boss/Elite ch·ªâ l√† "combat to" (kh√¥ng c√≤n h·ªá linh ki·ªán/ng√†y c≈©)
        if (bossMode) {
            const bossName = pickRandom(BOSS_NAMES);
            // Nerf nh·∫π ƒë·ªÉ boss "y·∫øu y√™u" h∆°n m·ªôt ch√∫t (v·∫´n scale theo kho·∫£ng c√°ch)
            const m = 1.65 + (dist * 0.065);
            let traits = [];
            for (let i = 0; i < 4; i++) {
                const tr = generateSynergyTrait(pickRandom(TIERS_DB.filter(t => t.rare >= 3)));
                const tlv = rollBossTraitLevel(dist);
                tr.level = tlv;
                tr.baseVal = Number(tr.baseVal ?? tr.val ?? 0);
                tr.val = tr.baseVal;
                tr.totalVal = tr.baseVal * tlv;
                traits.push(tr);
            }
            // Boss c≈©ng ƒë∆∞·ª£c c·ªông ch·ªâ s·ªë t·ª´ trait (nh∆∞ qu√°i th∆∞·ªùng), nh∆∞ng ƒë√£ c√≥ scale ri√™ng t·ª´ m.
            let base = { hp: Math.floor(205 * m), maxHp: Math.floor(205 * m), atk: Math.floor(25 * m), def: Math.floor(7 * m), spd: Math.floor(9 * m) };
            let regen = 0;
            traits.forEach(t => {
                const v = Number(t.totalVal ?? t.val ?? 0);
                if (t.type === "HP") { base.hp += v; base.maxHp += v; }
                if (t.type === "ATK") base.atk += v;
                if (t.type === "DEF") base.def += v;
                if (t.type === "SPD") base.spd += v;
                if (t.type === "REGEN") regen += v;
            });
            currentEnemies.push({
                id: 0,
                name: bossName,
                isBoss: true,
                stats: base,
                traits,
                regen,
                alive: true,
                selected: false
            });
            log(`üî•üî• B√ÅO ƒê·ªòNG: ${bossName} XU·∫§T HI·ªÜN!`, "boss");
        } else {
            const count = rand(1, 3);
            for (let i = 0; i < count; i++) {
                const level = rand(z.levelMin, z.levelMax);
                const m = 1 + (level / 6) + (dist * 0.02);
                let traits = [];
                let tc = rand(1, 3);
                for (let k = 0; k < tc; k++) {
                    const tr = generateSynergyTrait();
                    // level trait qu√°i theo kho·∫£ng c√°ch (c√¢n b·∫±ng: cap + bias)
                    const tlv = rollEnemyTraitLevel(dist);
                    tr.level = tlv;
                    tr.baseVal = Number(tr.baseVal ?? tr.val ?? 0);
                    tr.val = tr.baseVal; // val = tƒÉng g·∫ßn nh·∫•t (ƒë·ªëi v·ªõi qu√°i: gi·ªØ b·∫±ng base)
                    tr.totalVal = tr.baseVal * tlv;
                    traits.push(tr);
                }
                let base = { hp: 40 * m, maxHp: 40 * m, atk: 10 * m, def: 0, spd: 5 };
                let regen = 0;
                traits.forEach(t => {
                    const v = Number(t.totalVal ?? t.val ?? 0);
                    if (t.type === "HP") { base.hp += v; base.maxHp += v; }
                    if (t.type === "ATK") base.atk += v;
                    if (t.type === "DEF") base.def += v;
                    if (t.type === "SPD") base.spd += v;
                    if (t.type === "REGEN") regen += v;
                });

                const baseName = pickRandom(currentWorldDef().enemies || ENTITIES);
                const tier = strongestTraitLabel(traits);
                const fullName = tier ? `${baseName} ‚Ä¢ ${tier}` : baseName;
                currentEnemies.push({ id: i, name: fullName, baseName, isBoss: false, stats: base, traits, regen, alive: true, selected: false });
            }
            log(`Ph√°t hi·ªán ${count} k·∫ª ƒë·ªãch ch·∫∑n ƒë∆∞·ªùng.`);
        }
        setCombatMode(true);
        toggleInput(false);
        renderEnemies();
    }
    function renderEnemies() {
        const div = $("e-list"); div.innerHTML = "";
        currentEnemies.forEach(e => {
            let hpPct = (e.stats.hp / e.stats.maxHp) * 100;
            let el = document.createElement("div");
            el.className = `enemy-card ${e.isBoss ? 'boss' : ''} ${e.alive ? '' : 'dead'} ${e.selected ? 'selected' : ''}`;
            el.onclick = () => { if(e.alive) { currentEnemies.forEach(x => x.selected = false); e.selected = true; renderEnemies(); } };
            el.innerHTML = `<span class="enemy-name">${e.name}</span><div class="enemy-hp-bar"><div class="enemy-hp-fill" style="width:${hpPct}%"></div></div><small>HP: ${Math.ceil(e.stats.hp)} | ATK: ${Math.ceil(e.stats.atk)}</small><br><div style="margin-top:4px;">${traitTagsHTML(e.traits)}</div>`;
            div.appendChild(el);
        });
    }

    function strongestTraitLabel(traits) {
        if (!traits?.length) return "";
        const ts = traits.map(normTrait);
        ts.sort((a, b) => (b.rare - a.rare) || (traitTotalVal(b) - traitTotalVal(a)));
        const t = ts[0];
        if (!t) return "";
        if (t.type === "REGEN") return `T√°i Sinh Mk.${Math.max(1, Math.round(Number(t.baseVal ?? 4) / 4))}`;
        return t.element || t.name;
    }

    function openCombatEvoGunChoice(targetId) {
        const target = currentEnemies.find(x => x.id === targetId);
        if (!target || !target.alive) {
            log("M·ª•c ti√™u kh√¥ng h·ª£p l·ªá.", "danger");
            toggleInput(false);
            return;
        }
        const body = `
            <div style="text-align:left;">
                <div style="color:#8b949e;font-size:12px;margin-bottom:10px;">Ch·ªçn ch·∫ø ƒë·ªô b·∫Øn l√™n <strong style="color:#fff">${target.name}</strong>:</div>
                <button class="evo-option" data-cgev="${targetId}" data-mode="debuff">üß™ Tho√°i h√≥a (Gi·∫£m ch·ªâ s·ªë)</button>
                <button class="evo-option" data-cgev="${targetId}" data-mode="cleanse">üß¨ T·∫©y Gen (X√≥a 1 ƒë·∫∑c t√≠nh c·ªßa ƒë·ªãch)</button>
                <div style="margin-top:10px;color:#8b949e;font-size:11px;">H·ªßy s·∫Ω kh√¥ng m·∫•t l∆∞·ª£t.</div>
            </div>
        `;
        // Khi m·ªü modal ch·ªçn, t·∫°m th·ªùi kh√¥ng cho thao t√°c kh√°c; n·∫øu h·ªßy th√¨ tr·∫£ l·∫°i l∆∞·ª£t
        showModal("S√öNG TI·∫æN H√ìA", "", false, body);
        const btn = $("btn-close-modal");
        if (btn) {
            btn.innerText = "H·ªßy";
            btn.onclick = () => { closeModal(); toggleInput(false); };
        }
    }

    function combatEvoGunChoose(targetId, mode) {
        const t = currentEnemies.find(x => x.id === targetId);
        if (!t || !t.alive) {
            closeModal();
            log("M·ª•c ti√™u kh√¥ng c√≤n s·ªëng.", "danger");
            toggleInput(false);
            return; 
        }

        closeModal();

        if (mode === "debuff") {
            t.stats.atk = Math.floor(t.stats.atk * 0.6);
            t.stats.def = Math.floor(t.stats.def * 0.6);
            t.stats.hp -= 15;
                    log(`Tho√°i h√≥a ${t.name}: Ch·ªâ s·ªë gi·∫£m m·∫°nh!`);
        } else if (mode === "cleanse") {
                    if (t.traits.length > 0) {
                let ridx = rand(0, t.traits.length - 1);
                        let removed = t.traits.splice(ridx, 1)[0];
                const removedTotal = Number(removed?.totalVal ?? removed?.val ?? 0);
                if (removed.type === "ATK") t.stats.atk -= removedTotal;
                if (removed.type === "DEF") t.stats.def -= removedTotal;
                if (removed.type === "HP") {
                    t.stats.maxHp -= removedTotal;
                    t.stats.hp = Math.min(t.stats.hp, t.stats.maxHp);
                }
                if (removed.type === "SPD") t.stats.spd -= removedTotal;
                if (removed.type === "REGEN") {
                    // REGEN c·ªßa qu√°i/boss ƒëang ƒë∆∞·ª£c cache ·ªü t.regen (tick m·ªói l∆∞·ª£t)
                    t.regen = Math.max(0, Number(t.regen || 0) - removedTotal);
                }
                        log(`T·∫©y Gen ${t.name}: M·∫•t ƒë·∫∑c t√≠nh [${removed.name}]!`, "success");
            } else {
                log(`${t.name} kh√¥ng c√≤n Gen n√†o ƒë·ªÉ x√≥a!`, "danger");
            }
        } else {
            // mode kh√¥ng h·ª£p l·ªá -> kh√¥ng m·∫•t l∆∞·ª£t
            log("Ch·∫ø ƒë·ªô kh√¥ng h·ª£p l·ªá.", "danger");
            toggleInput(false);
            return;
        }

        // K·∫øt th√∫c l∆∞·ª£t c·ªßa ng∆∞·ªùi ch∆°i
        currentEnemies.forEach(e => { if (e.stats.hp <= 0) e.alive = false; });
        renderEnemies();
        updateUI();
        if (currentEnemies.every(e => !e.alive)) endCombat(true);
        else setTimeout(enemiesTurn, 500);
    }

    const ACTIONS = {
        counter_mantle: {
            needsTarget: false,
            run: () => { isCountering = true; log("Tung KhƒÉn Cho√†ng A-l√™-h·∫•p!", "info"); setTimeout(enemiesTurn, 500); return { handled: true }; }
        },
        use_medkit: {
            needsTarget: false,
            run: () => {
                if (player.items.medkit <= 0) { log("H·∫øt thu·ªëc! Kh√¥ng th·ªÉ d√πng trong chi·∫øn ƒë·∫•u.", "danger"); toggleInput(false); return { handled: true }; }
                player.items.medkit--;
                const before = player.hp;
                player.hp = Math.min(player.maxHp, player.hp + 70);
                log(`D√πng thu·ªëc trong chi·∫øn ƒë·∫•u (+${player.hp - before} HP).`, "new");
                updateUI();
                setTimeout(enemiesTurn, 500);
                return { handled: true };
            }
        },
        anywhere_door: { needsTarget: false, run: () => { log("M·ªü C·ª≠a Th·∫ßn K·ª≥... Ch·∫°y tho√°t th√†nh c√¥ng!", "info"); endCombat(false); return { handled: true }; } },
        evo_gun_enemy: { needsTarget: true, run: (t) => { openCombatEvoGunChoice(t.id); return { handled: true }; } },
        dictator_switch: {
            needsTarget: true,
            run: (t) => {
                if (t.isBoss) { log("Boss mi·ªÖn nhi·ªÖm!", "danger"); return { handled: true }; }
                // popup x√°c nh·∫≠n (kh√¥ng d√πng confirm)
                openConfirm({
                    title: "C√îNG T·∫ÆC ƒê·ªòC T√ÄI",
                    desc: `B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a s·ªï <strong style="color:#fff">${t.name}</strong>?<br><br><span style="color:#ff7b72;font-weight:800;">L∆∞u √Ω:</span> Kh√¥ng c√≥ loot.`,
                    yesText: "X√ìA S·ªî",
                    noText: "H·ª¶Y",
                    onYes: () => {
                        t.stats.hp = 0;
                        t.noLoot = true;
                        log(`${t.name} b·ªã x√≥a s·ªï.`, "danger");
                        closeModal();
                        // k·∫øt th√∫c l∆∞·ª£t
                        resolveEndOfPlayerTurn();
                    },
                    onNo: () => {
                        toggleInput(false); // kh√¥ng m·∫•t l∆∞·ª£t
                    }
                });
                return { handled: true };
            }
        },
        air_cannon: { needsTarget: true, run: (t) => { 
            const dmg = Math.max(1, playerAtkEff() - t.stats.def); 
            t.stats.hp -= (Math.floor(dmg * 2.5) + 20); 
            log(`ƒê·∫°i b√°c b·∫Øn ${t.name}: ST l·ªõn!`); 
            applyRegenCounterOnHit(t);
        } },
        basic: {
            needsTarget: true,
            run: (t) => {
                let dmg = Math.max(1, playerAtkEff() - t.stats.def);
                if (player.traits.some(x => x.passive === "PIERCE")) { dmg = Math.max(1, playerAtkEff() - (t.stats.def / 2)); log("Xuy√™n Gi√°p!", "success"); }
                if (player.traits.some(x => x.passive === "BURN")) { dmg += 5; log("Thi√™u ƒë·ªët +5 DMG!", "danger"); }
                if (player.traits.some(x => x.passive === "LIFESTEAL")) { let h = Math.ceil(dmg * 0.2); player.hp = Math.min(player.maxHp, player.hp + h); log(`H√∫t ${h} HP!`, "new"); }
                t.stats.hp -= dmg; log(`T·∫•n c√¥ng ${t.name}: ${Math.floor(dmg)} ST.`);
                applyRegenCounterOnHit(t);
            }
        }
    };

    function resolveEndOfPlayerTurn() {
        currentEnemies.forEach(e => { if (e.stats.hp <= 0) e.alive = false; });
        renderEnemies();
        if (currentEnemies.every(e => !e.alive)) endCombat(true);
        else setTimeout(enemiesTurn, 500);
    }

    function getSelectedTarget() {
        let targets = currentEnemies.filter(e => e.selected && e.alive);
        if (targets.length === 0 && currentEnemies.filter(e => e.alive).length === 1) targets = [currentEnemies.find(e => e.alive)];
        return targets[0] || null;
    }

    function applyRegenCounterOnHit(target) {
        if (!target || !target.alive) return;
        if (nnum(target?.regen, 0) <= 0) return;

        const hasVoid = hasPassive(player.traits, "DECAY_WOUND");
        const hasPoison = hasPassive(player.traits, "TOXIC_WOUND");
        const hasIce = hasPassive(player.traits, "FROST_BITE");

        // Rule stacking:
        // - Kh√°c lo·∫°i c√≥ th·ªÉ c·ªông d·ªìn (VOID block + POISON weaken + ICE weaken).
        // - C√πng lo·∫°i kh√¥ng c·ªông d·ªìn: ch·ªâ refresh l∆∞·ª£t l·ªõn nh·∫•t.
        if (hasVoid) {
            const before = nnum(target.regenBlockTurns, 0);
            const after = setMaxTurns(target, "regenBlockTurns", REGEN_COUNTER.blockTurns);
            if (after !== before) log(`ü©∏ V·∫øt th∆∞∆°ng h∆∞ v√¥: Ch·∫∑n t√°i sinh c·ªßa ${target.name} (${REGEN_COUNTER.blockTurns} l∆∞·ª£t)!`, "danger");
        }
        if (hasPoison) {
            const before = nnum(target.regenPoisonWeakenTurns, 0);
            const after = setMaxTurns(target, "regenPoisonWeakenTurns", REGEN_COUNTER.poison.turns);
            if (after !== before) log(`üß™ ƒê·ªôc: T√°i sinh c·ªßa ${target.name} y·∫øu c√≤n ${Math.round(REGEN_COUNTER.poison.mul * 100)}% (${REGEN_COUNTER.poison.turns} l∆∞·ª£t)!`, "danger");
        }
        if (hasIce) {
            const before = nnum(target.regenIceWeakenTurns, 0);
            const after = setMaxTurns(target, "regenIceWeakenTurns", REGEN_COUNTER.ice.turns);
            if (after !== before) log(`üßä BƒÉng: T√°i sinh c·ªßa ${target.name} y·∫øu c√≤n ${Math.round(REGEN_COUNTER.ice.mul * 100)}% (${REGEN_COUNTER.ice.turns} l∆∞·ª£t)!`, "danger");
        }
    }

    function applyRegenCounterOnPlayerHit(attacker) {
        if (!attacker || !attacker.alive) return;
        if (nnum(player?.regen, 0) <= 0) return;

        const traits = attacker.traits || [];
        const hasVoid = hasPassive(traits, "DECAY_WOUND");
        const hasPoison = hasPassive(traits, "TOXIC_WOUND");
        const hasIce = hasPassive(traits, "FROST_BITE");

        // Rule stacking:
        // - Kh√°c lo·∫°i c√≥ th·ªÉ c·ªông d·ªìn.
        // - C√πng lo·∫°i kh√¥ng c·ªông d·ªìn: ch·ªâ refresh l∆∞·ª£t l·ªõn nh·∫•t.
        if (hasVoid) {
            const before = nnum(player.regenBlockTurns, 0);
            const after = setMaxTurns(player, "regenBlockTurns", REGEN_COUNTER.blockTurns);
            if (after !== before) log(`ü©∏ ${attacker.name}: V·∫øt th∆∞∆°ng h∆∞ v√¥ ch·∫∑n t√°i sinh c·ªßa b·∫°n (${REGEN_COUNTER.blockTurns} l∆∞·ª£t)!`, "danger");
        }
        if (hasPoison) {
            const before = nnum(player.regenPoisonWeakenTurns, 0);
            const after = setMaxTurns(player, "regenPoisonWeakenTurns", REGEN_COUNTER.poison.turns);
            if (after !== before) log(`üß™ ${attacker.name}: ƒê·ªôc l√†m y·∫øu t√°i sinh c·ªßa b·∫°n c√≤n ${Math.round(REGEN_COUNTER.poison.mul * 100)}% (${REGEN_COUNTER.poison.turns} l∆∞·ª£t)!`, "danger");
        }
        if (hasIce) {
            const before = nnum(player.regenIceWeakenTurns, 0);
            const after = setMaxTurns(player, "regenIceWeakenTurns", REGEN_COUNTER.ice.turns);
            if (after !== before) log(`üßä ${attacker.name}: BƒÉng l√†m y·∫øu t√°i sinh c·ªßa b·∫°n c√≤n ${Math.round(REGEN_COUNTER.ice.mul * 100)}% (${REGEN_COUNTER.ice.turns} l∆∞·ª£t)!`, "danger");
        }
    }

    function performAction(type) {
        const action = ACTIONS[type];
        if (!action) { log("H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá!", "danger"); return; }
        const target = getSelectedTarget();
        if (action.needsTarget && !target) { log("H√£y ch·ªçn m·ª•c ti√™u!", "danger"); return; }

        toggleInput(true);
        const res = action.run(target);
        if (res?.handled) return;
        resolveEndOfPlayerTurn();
    }

    function enemiesTurn() {
        if(currentEnemies.every(e=>!e.alive)) { endCombat(true); return; }
        log("--- L∆∞·ª£t k·∫ª ƒë·ªãch ---", "info");

        // REGEN tick ·ªü ƒë·∫ßu l∆∞·ª£t ƒë·ªãch (ƒë·ªÉ trait "T·∫ø B√†o T√°i Sinh" c·ªßa qu√°i/boss c√≥ t√°c d·ª•ng)
        let regenLogParts = [];
        currentEnemies.forEach(e => {
            if (!e?.alive) return;
            const r = nnum(e.regen, 0);
            if (r <= 0) return;
            if (nnum(e.regenBlockTurns, 0) > 0) {
                e.regenBlockTurns = Math.max(0, nnum(e.regenBlockTurns, 0) - 1);
                // kh√¥ng heal trong l∆∞·ª£t b·ªã ch·∫∑n
                return;
            }
            let mul = 1;
            if (nnum(e.regenPoisonWeakenTurns, 0) > 0) {
                mul *= REGEN_COUNTER.poison.mul;
                e.regenPoisonWeakenTurns = Math.max(0, nnum(e.regenPoisonWeakenTurns, 0) - 1);
            }
            if (nnum(e.regenIceWeakenTurns, 0) > 0) {
                mul *= REGEN_COUNTER.ice.mul;
                e.regenIceWeakenTurns = Math.max(0, nnum(e.regenIceWeakenTurns, 0) - 1);
            }
            const before = e.stats.hp;
            const healAmt = Math.floor(r * mul);
            e.stats.hp = Math.min(e.stats.maxHp, e.stats.hp + healAmt);
            const healed = e.stats.hp - before;
            if (healed > 0) regenLogParts.push(`${e.name} +${Math.ceil(healed)} HP`);
        });

        // N·∫øu regen c√≥ x·∫£y ra, c·∫ßn "yield" ƒë·ªÉ browser k·ªãp paint HP tr∆∞·ªõc khi qu√°i ƒë√°nh / b·ªã ph·∫£n ƒë√≤n.
        if (regenLogParts.length) {
            log(`‚ú® T·∫ø B√†o T√°i Sinh: ${regenLogParts.join(", ")}.`, "success");
            renderEnemies();
            updateUI();
            setTimeout(enemiesTurnPhase2, 60);
            return;
        }
        enemiesTurnPhase2();
    }

    function enemiesTurnPhase2() {
        let totalDmg = 0;
        currentEnemies.forEach(e => {
            if (e.alive) {
                if (isCountering) { let r = Math.floor(e.stats.atk*1.5); e.stats.hp-=r; log(`‚ú® A-l√™-h·∫•p! ƒê√≤n c·ªßa ${e.name} b·ªã h·∫•t ng∆∞·ª£c l·∫°i (${r} ST)!`,"success"); }
                else {
                    let d = Math.max(1, e.stats.atk - player.def);
                    let chance = (playerSpdEff() - e.stats.spd)*2;
                    if(player.traits.some(x=>x.passive==="FREEZE_AURA")) chance+=10;
                    if(Math.random()*100 < chance) log(`N√© ƒë∆∞·ª£c ƒë√≤n c·ªßa ${e.name}!`,"success");
                    else { 
                        if(player.traits.some(x=>x.passive==="POISON_SKIN")){e.stats.hp-=3;log(`${e.name} tr√∫ng ƒë·ªôc (-3 HP)`,"success");}
                        // qu√°i/boss c√≥ th·ªÉ kh·∫Øc ch·∫ø ng∆∞·ª£c l·∫°i t√°i sinh c·ªßa ng∆∞·ªùi ch∆°i n·∫øu ƒë√≤n tr√∫ng
                        applyRegenCounterOnPlayerHit(e);
                        totalDmg+=d; log(`${e.name} g√¢y ${d} ST!`,"danger"); 
                    }
                }
            }
        });
        if(!isCountering) player.hp-=totalDmg; isCountering=false;
        if (player.hp <= 0) { log("‚ò†Ô∏è B·∫°n ƒë√£ g·ª•c ng√£...", "danger"); updateUI(); return; }
        if(player.traits.some(x=>x.passive==="REACTOR")){player.genPoints+=5;player.hp-=2;log("Tim H·∫°t Nh√¢n: +5 Gen, -2 HP","boss"); if(player.hp<=0){updateUI();return;}}

        // REGEN tick ·ªü cu·ªëi l∆∞·ª£t ƒë·ªãch (ƒë·∫ßu l∆∞·ª£t ng∆∞·ªùi ch∆°i) + ch·ªãu debuff (ƒë·ªëi x·ª©ng v·ªõi qu√°i)
        if (player.regen > 0) {
            if (nnum(player.regenBlockTurns, 0) > 0) {
                player.regenBlockTurns = Math.max(0, nnum(player.regenBlockTurns, 0) - 1);
            } else {
                let mul = 1;
                if (nnum(player.regenPoisonWeakenTurns, 0) > 0) {
                    mul *= REGEN_COUNTER.poison.mul;
                    player.regenPoisonWeakenTurns = Math.max(0, nnum(player.regenPoisonWeakenTurns, 0) - 1);
                }
                if (nnum(player.regenIceWeakenTurns, 0) > 0) {
                    mul *= REGEN_COUNTER.ice.mul;
                    player.regenIceWeakenTurns = Math.max(0, nnum(player.regenIceWeakenTurns, 0) - 1);
                }
                const before = player.hp;
                const healAmt = Math.floor(Number(player.regen || 0) * mul);
                player.hp = Math.min(player.maxHp, player.hp + healAmt);
                const healed = player.hp - before;
                if (healed > 0) log(`‚ú® T·∫ø B√†o T√°i Sinh h·ªìi ${healed} HP.`, "success");
            }
        }

        currentEnemies.forEach(e => { if(e.stats.hp<=0) e.alive=false; });
        renderEnemies();
        updateUI();
        if(currentEnemies.every(e=>!e.alive)) endCombat(true); else toggleInput(false);
    }

    function biomeHealMult() {
        const p = currentWorldDef().passive || {};
        return typeof p.healMult === "number" ? p.healMult : 1;
    }
    function biomeAtkMult() {
        const p = currentWorldDef().passive || {};
        return typeof p.atkMult === "number" ? p.atkMult : 1;
    }
    function biomeSpdPenalty() {
        const p = currentWorldDef().passive || {};
        return typeof p.spdPenalty === "number" ? p.spdPenalty : 0;
    }
    function biomeDisableMeat() {
        const p = currentWorldDef().passive || {};
        return !!p.disableMeat;
    }
    function playerAtkEff() { return Math.max(1, Math.floor(player.atk * biomeAtkMult())); }
    function playerSpdEff() { return Math.max(0, player.spd - biomeSpdPenalty()); }

    function updateMapUI() {
        const map = $("mini-map");
        if (!map) return;
        const size = 5;
        const half = Math.floor(size / 2);
        let html = "";
        for (let dy = half; dy >= -half; dy--) {
            for (let dx = -half; dx <= half; dx++) {
                const x = player.x + dx;
                const y = player.y + dy;
                const d = manhattan(x, y);
                const z = zoneForDist(d);
                const tile = getWorld().data[posKey(x, y)];
                const isPlayer = dx === 0 && dy === 0;
                const cls = ["map-cell"];
                if (!tile) cls.push("unknown");
                else cls.push(tile.visited ? "visited" : "visited");
                if (tile?.type === "START") cls.push("start");
                if (tile?.type === "BEACON" && !tile?.cleared) cls.push("beacon");
                if (z.name === "Nguy Hi·ªÉm") cls.push("zone-danger");
                if (z.name === "T·ª≠ Th·∫ßn") cls.push("zone-death");
                if (isPlayer) cls.push("player");
                const label = isPlayer ? "P" : (tile?.type === "START" ? "S" : (tile?.type === "BEACON" && !tile?.cleared ? "B" : ""));
                html += `<div class="${cls.join(" ")}" title="(${x},${y}) ‚Ä¢ Dist ${d}">${label}</div>`;
            }
        }
        map.innerHTML = html;
    }

    function updateQuestUI() {
        // Apply per-world palette (map colors)
        document.body.dataset.world = player.worldId;

        $("w-name").innerText = currentWorldDef().name;
        $("p-pos").innerText = `(${player.x},${player.y})`;
        const d = manhattan(player.x, player.y);
        $("p-dist").innerText = `${d} (${zoneForDist(d).name})`;
        $("p-frag").innerText = `${player.fragments}/3`;
        $("quest-bar").style.width = `${(player.fragments/3)*100}%`;
        const portalReady = player.fragments >= 3 && d === 0;
        $("btn-portal").classList.toggle("hidden", !portalReady);
        $("p-day").innerText = `${player.gameDay}`;
        const tmReady = (player.items.energy >= 10) && d === 0 && !player.timeMachineStarted;
        $("btn-time-machine").classList.toggle("hidden", !tmReady);

        // Hint ƒë·ªông: % event theo ng√†y + boss theo t·ªça ƒë·ªô
        const w = getWorld();
        const tile = w?.data?.[posKey(player.x, player.y)];
        const daysAway = tile?.lastVisitDay ? Math.max(0, player.gameDay - Number(tile.lastVisitDay)) : 0;
        const zone = zoneForDist(d);
        const evPct = tile?.visited ? computeRevisitEventChancePct(daysAway, zone) : 100;
        const isRevisit = Number(tile?.visitCount ?? 1) >= 2;
        const bc = Math.round(
            bossSpawnChanceHere({ isRevisit, eventChance: (Math.max(0, Math.min(100, evPct)) / 100) }) * 1000
        ) / 10; // 1 ch·ªØ s·ªë th·∫≠p ph√¢n
        const deathHint = player.hasEnteredDeathZone ? " (Boss c√≥ th·ªÉ xu·∫•t hi·ªán kh·∫Øp n∆°i)" : "";
        const eventHere = (tile?.visitCount ?? 1) <= 1 ? "100%" : `${Math.round(evPct * 10) / 10}%`;
        $("next-event").innerText = `V·ªã tr√≠ n√†y: S·ª± ki·ªán ${eventHere} (v·∫Øng ${daysAway} ng√†y) ‚Ä¢ Boss ${bc}%${deathHint}.`;
    }

    function syncGameDayFromSteps() {
        const newDay = 1 + Math.floor(Math.max(0, player.steps) / STEPS_PER_DAY);
        if (newDay <= player.gameDay) return;
        player.gameDay = newDay;
        log(`üìÖ Sang ng√†y ${player.gameDay}.`, "info");
    }

    function zoneEventParams(z) {
        const name = z?.name || "";
        if (name === "T·ª≠ Th·∫ßn") return { cap: 100, speed: 2.0 };
        if (name === "Nguy Hi·ªÉm") return { cap: 90, speed: 1.5 };
        return { cap: 70, speed: 1.0 };
    }

    function computeRevisitEventChancePct(daysAway, zone) {
        const { cap, speed } = zoneEventParams(zone);
        let chance = 1;
        const n = Math.max(0, Math.floor(daysAway || 0));
        // tƒÉng random 1-70% m·ªói ng√†y v·∫Øng m·∫∑t (10 b∆∞·ªõc = 1 ng√†y); v√πng c√†ng nguy hi·ªÉm tƒÉng nhanh h∆°n
        for (let i = 0; i < n && chance < cap; i++) {
            const inc = Math.max(1, Math.round(rand(1, 70) * speed));
            chance = Math.min(cap, chance + inc);
        }
        return chance;
    }

    function coordBossChanceAfterDeath(x, y) {
        // Sau khi ƒë√£ v√†o v√πng T·ª≠ Th·∫ßn: boss c√≥ th·ªÉ xu·∫•t hi·ªán ·ªü b·∫•t c·ª© ƒë√¢u
        // Rule m·ªõi:
        // - M·ªçi √¥: 1%
        // - Ch·ªâ √¥ c√≥ t·ªça ƒë·ªô x=y: 10%
        // - Ch·ªâ √¥ c√≥ x=y v√† (x=y) chia h·∫øt cho 10: 90%
        if (x === y) {
            if (x % 10 === 0) return 0.90;
            return 0.10;
        }
        return 0.01;
    }

    function coordBossChanceBeforeDeath(x, y) {
        // Tr∆∞·ªõc khi v√†o T·ª≠ Th·∫ßn: boss ch·ªâ ƒëi tu·∫ßn ·ªü v√πng Nguy Hi·ªÉm tr·ªü l√™n.
        // Gi·∫£m nh·∫π so v·ªõi h·∫≠u-T·ª≠ Th·∫ßn ƒë·ªÉ ƒë·ª° "spam" boss qu√° s·ªõm.
        return coordBossChanceAfterDeath(x, y) * 0.40;
    }

    function baseBossSpawnChanceHere() {
        const d = manhattan(player.x, player.y);
        const z = zoneForDist(d);

        // Track unlock: v·ª´a ƒë·∫∑t ch√¢n v√†o T·ª≠ Th·∫ßn l√† m·ªü c∆° ch·∫ø "xu·∫•t hi·ªán kh·∫Øp n∆°i"
        if (z.name === "T·ª≠ Th·∫ßn") player.hasEnteredDeathZone = true;

        let base = 0;
        if (player.hasEnteredDeathZone) {
            base = coordBossChanceAfterDeath(player.x, player.y);
        } else {
            if (z.name !== "Nguy Hi·ªÉm" && z.name !== "T·ª≠ Th·∫ßn") return 0;
            base = coordBossChanceBeforeDeath(player.x, player.y);
        }

        return base;
    }

    function bossSpawnChanceHere({ isRevisit = false, eventChance = 1 } = {}) {
        let chance = baseBossSpawnChanceHere();
        if (isRevisit) {
            const m = Math.max(0, Math.min(1, Number(eventChance) || 0));
            chance *= m;
        }
        return chance;
    }

    function trySpawnBossPatrol({ isRevisit = false, eventChance = 1 } = {}) {
        const chance = bossSpawnChanceHere({ isRevisit, eventChance });
        if (chance <= 0) return false;
        if (Math.random() < chance) {
            startCombat(true);
            return true;
        }
        return false;
    }

    function maybePickupBeacon(tile) {
        if (tile?.type === "BEACON" && !tile.cleared) {
            tile.cleared = true;
            player.fragments = Math.min(3, player.fragments + 1);
            log(`üì° Thu ƒë∆∞·ª£c 1 M·∫¢NH T·ªåA ƒê·ªò! (${player.fragments}/3)`, "new");
            updateUI();
            return true;
        }
        return false;
    }

    function applyBiomeStepEffects() {
        const w = currentWorldDef();
        const p = w.passive || {};
        if (p.poisonEverySteps && player.steps > 0 && player.steps % p.poisonEverySteps === 0) {
            player.hp = Math.max(1, player.hp - (p.poisonHp || 5));
            log(`${w.name}: Nhi·ªÖm ƒë·ªôc nh·∫π (-${p.poisonHp || 5} HP).`, "danger");
        }
    }

    function applyStepRegen() {
        const r = Number(player.regen || 0);
        if (r <= 0) return;
        if (player.hp <= 0) return;
        const before = player.hp;
        player.hp = Math.min(player.maxHp, player.hp + r);
        const healed = player.hp - before;
        if (healed > 0) log(`‚ú® T·∫ø B√†o T√°i Sinh h·ªìi ${healed} HP.`, "success");
    }

    function advanceTimeSteps(n = 1) {
        const steps = Math.max(0, Math.floor(Number(n) || 0));
        if (steps <= 0) return;
        const w = getWorld();
        for (let i = 0; i < steps; i++) {
            player.steps += 1;
            w.steps += 1;
            syncGameDayFromSteps();
            applyBiomeStepEffects();
            applyStepRegen();
        }
    }

    function handleTileEvent(tile, isNewTile) {
        // New tile: lu√¥n c√≥ s·ª± ki·ªán.
        // Revisit: caller s·∫Ω roll % theo ng√†y.
        // Beacon x·ª≠ l√Ω ri√™ng ƒë·ªÉ kh√¥ng k·∫πt ti·∫øn ƒë·ªô.

        // Encounter vs loot
        const d = manhattan(player.x, player.y);
        const z = zoneForDist(d);
        const combatChance = isNewTile ? 0.55 : 0.6;
        if (Math.random() < combatChance) startCombat(false);
        else {
            // loot scaling nh·∫π theo zone
            let bonus = z.name === "Nguy Hi·ªÉm" ? 1 : z.name === "T·ª≠ Th·∫ßn" ? 2 : 0;
            player.items.meat += (Math.random() < 0.5 ? 1 + bonus : 0);
            player.genPoints += (10 + bonus * 10);
            if (Math.random() < 0.15 + bonus * 0.05) player.items.medkit += 1;
            log(`T√†n d∆∞: +${10 + bonus * 10} Gen${bonus?` (v√πng ${z.name})`:""}.`, "new");
            updateUI();
        }
    }

    function move(dx, dy) {
        if ($("combat-area")?.classList.contains("hidden") === false) { log("ƒêang giao chi·∫øn, kh√¥ng th·ªÉ di chuy·ªÉn!", "danger"); return; }
        player.x += dx; player.y += dy;
        advanceTimeSteps(1);
        const tile = getTile(player.x, player.y);
        const prevLastVisitDay = Number(tile.lastVisitDay ?? 0);
        tile.visitCount = Number(tile.visitCount ?? 0) + 1;
        const isNew = !tile.visited;
        const zone = zoneForDist(manhattan(player.x, player.y));
        const daysAway = tile.visited ? Math.max(0, player.gameDay - prevLastVisitDay) : 0;
        const revisitEventPct = tile.visited ? computeRevisitEventChancePct(daysAway, zone) : 100;
        tile.visited = true;
        // lu√¥n l∆∞u "ng√†y ƒë·∫∑t ch√¢n ƒë·∫øn" d√π c√≥/kh√¥ng c√≥ g√¨
        tile.lastVisitDay = player.gameDay;
        log(`ƒê·∫∑t ch√¢n t·ªõi v·ªã tr√≠ (${player.x},${player.y}) ‚Ä¢ Dist ${manhattan(player.x, player.y)}.`, "info");

        // 1) Beacon lu√¥n nh·∫∑t ƒë∆∞·ª£c (kh√¥ng ph·ª• thu·ªôc % s·ª± ki·ªán)
        const beaconPicked = maybePickupBeacon(tile);

        // 2) Boss ƒëi tu·∫ßn
        // - √î m·ªõi: d√πng base chance
        // - √î ƒë√£ ƒëi qua: nh√¢n th√™m v·ªõi t·ªâ l·ªá s·ª± ki·ªán (revisitEventPct)
        if (trySpawnBossPatrol({ isRevisit: !isNew, eventChance: (Math.max(0, Math.min(100, revisitEventPct)) / 100) })) {
            updateUI(); updateMapUI(); return;
        }

        // 3) S·ª± ki·ªán:
        // - V·ªã tr√≠ ch∆∞a kh√°m ph√°: ch·∫Øc ch·∫Øn c√≥ s·ª± ki·ªán (beacon c≈©ng t√≠nh l√† s·ª± ki·ªán)
        // - V·ªã tr√≠ ƒë√£ kh√°m ph√°: roll theo s·ªë ng√†y kh√¥ng ƒë·∫∑t ch√¢n t·ªõi (daysAway)
        if (isNew) {
            if (!beaconPicked) handleTileEvent(tile, true);
        } else {
            const eventChance = Math.max(0, Math.min(100, revisitEventPct)) / 100;
            if (Math.random() < eventChance) handleTileEvent(tile, false);
            else log("V·ªã tr√≠ n√†y kh√¥ng c√≥ s·ª± ki·ªán ƒë√°ng ch√∫ √Ω.", "info");
        }
        updateUI();
        updateMapUI();
    }

    function openPortal() {
        const d = manhattan(player.x, player.y);
        if (player.fragments < 3 || d !== 0) { log("C·∫ßn ƒë·ªß 3 m·∫£nh v√† ƒë·ª©ng t·∫°i (0,0).", "danger"); return; }
        const opts = WORLD_DB.filter(w => w.id !== player.worldId);
        const body = `<div style="text-align:left;">
            <div style="color:#8b949e;font-size:12px;margin-bottom:8px;">Ch·ªçn th·∫ø gi·ªõi ti·∫øp theo (t·ªça ƒë·ªô s·∫Ω reset v·ªÅ 0,0):</div>
            <button class="evo-option" data-world="__RANDOM__">üé≤ Ng·∫´u nhi√™n (m·ªü map m·ªõi)</button>
            ${opts.map(w => `<button class="evo-option" data-world="${w.id}">üåç ${w.name}</button>`).join("")}
        </div>`;
        showModal("C·ª¨A TH·∫¶N K·ª≤", "", false, body);
        const btn = $("btn-close-modal");
        if (btn) { btn.innerText = "ƒê√≥ng"; btn.onclick = closeModal; }
    }

    function visitedKeys(worldId = player.worldId) {
        const w = worlds[worldId];
        if (!w) return [];
        return Object.entries(w.data)
            .filter(([, t]) => t && t.visited)
            .map(([k]) => k);
    }
    function parseCoord(str) {
        if (!str) return null;
        const m = String(str).trim().match(/^(-?\d+)\s*,\s*(-?\d+)$/);
        if (!m) return null;
        return { x: Number(m[1]), y: Number(m[2]) };
    }
    function teleportTo(worldId, x, y) {
        const w = worlds[worldId];
        if (!w) { log("Ch∆∞a c√≥ d·ªØ li·ªáu map c·ªßa th·∫ø gi·ªõi n√†y.", "danger"); return; }
        const k = posKey(x, y);
        const tile = w.data[k];
        if (!tile?.visited && !(x === 0 && y === 0)) { log("Ch·ªâ d·ªãch chuy·ªÉn t·ªõi √¥ ƒë√£ t·ª´ng t·ªõi.", "danger"); return; }
        player.worldId = worldId;
        player.x = x; player.y = y;
        log(`üö™ D·ªãch chuy·ªÉn t·ªõi (${x},${y}) t·∫°i ${currentWorldDef().name}.`, "success");
        updateUI();
    }
    function openTeleport() {
        const worldIds = Object.keys(worlds);
        // ƒë·∫£m b·∫£o world hi·ªán t·∫°i ƒë√£ init
        getWorld();
        const wid = (window.__teleWorld && worlds[window.__teleWorld]) ? window.__teleWorld : player.worldId;
        const keys = visitedKeys(wid);
        const listId = "tele-coords";
        const body = `<div style="text-align:left;">
            <div style="color:#8b949e;font-size:12px;margin-bottom:8px;">D·ªãch chuy·ªÉn t·ªõi (0,0) ho·∫∑c √¥ ƒë√£ t·ª´ng gh√©.</div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;">
                <button class="evo-option" data-tele="home" data-w="${wid}">üè† V·ªÅ (0,0)</button>
                <button class="evo-option" data-tele="random" data-w="${wid}">üé≤ Ng·∫´u nhi√™n (√¥ ƒë√£ gh√©)</button>
            </div>
            <div style="margin-bottom:8px;">
                <div style="color:#8b949e;font-size:12px;margin-bottom:6px;">Ch·ªçn th·∫ø gi·ªõi:</div>
                <select data-tele-world style="width:100%;padding:10px;border-radius:8px;background:#0b0f14;color:#c9d1d9;border:1px solid var(--border-color);">
                    ${worldIds.map(id => `<option value="${id}" ${id===wid?"selected":""}>${(WORLD_DB.find(w=>w.id===id)?.name)||id}</option>`).join("")}
                </select>
            </div>
            <div>
                <div style="color:#8b949e;font-size:12px;margin-bottom:6px;">Nh·∫≠p t·ªça ƒë·ªô (x,y) (ch·ªâ √¥ ƒë√£ gh√©):</div>
                <input data-tele-input list="${listId}" placeholder="VD: 2,-1" style="width:100%;padding:10px;border-radius:8px;background:#0b0f14;color:#c9d1d9;border:1px solid var(--border-color);" />
                <datalist id="${listId}">
                    ${keys.slice(0, 300).map(k => `<option value="${k}"></option>`).join("")}
                </datalist>
                <button class="evo-option" data-tele="go" data-w="${wid}">‚úÖ D·ªãch chuy·ªÉn</button>
                <div style="margin-top:8px;color:#8b949e;font-size:11px;">Danh s√°ch g·ª£i √Ω hi·ªÉn th·ªã t·ªëi ƒëa 300 t·ªça ƒë·ªô ƒë√£ gh√©.</div>
            </div>
        </div>`;
        showModal("C·ª¨A TH·∫¶N K·ª≤", "", false, body);
        const btn = $("btn-close-modal");
        if (btn) { btn.innerText = "ƒê√≥ng"; btn.onclick = closeModal; }
    }

    function renderWorldMap(worldId) {
        const w = worlds[worldId];
        if (!w) return `<div style="color:#8b949e;">Ch∆∞a c√≥ d·ªØ li·ªáu.</div>`;
        const visited = Object.entries(w.data).filter(([,t])=>t && t.visited).map(([k])=>parseCoord(k)).filter(Boolean);
        if (!visited.length) return `<div style="color:#8b949e;">Ch∆∞a kh√°m ph√° √¥ n√†o.</div>`;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        visited.forEach(p => { minX = Math.min(minX,p.x); maxX = Math.max(maxX,p.x); minY = Math.min(minY,p.y); maxY = Math.max(maxY,p.y); });
        // padding nh·∫π
        minX -= 1; maxX += 1; minY -= 1; maxY += 1;
        const wdt = Math.min(60, Math.max(5, maxX - minX + 1));
        const hgt = Math.min(60, Math.max(5, maxY - minY + 1));
        // clamp bounds to fit 60x60 window (centered)
        if ((maxX - minX + 1) > 60) { const cx = Math.floor((minX+maxX)/2); minX = cx-30; maxX = cx+29; }
        if ((maxY - minY + 1) > 60) { const cy = Math.floor((minY+maxY)/2); minY = cy-30; maxY = cy+29; }

        const def = WORLD_DB.find(x=>x.id===worldId);
        const cols = (maxX - minX + 1);
        let html = `<div style="color:#8b949e;font-size:12px;margin-bottom:6px;">${def?.name||worldId} ‚Ä¢ Khung: x[${minX},${maxX}] y[${minY},${maxY}]</div>`;
        html += `<div class="world-map" data-world="${worldId}" style="overflow:auto;border:1px solid var(--border-color);border-radius:10px;padding:8px;background:#0b0f14;">
            <div style="display:grid;grid-template-columns:repeat(${cols}, 18px);gap:3px;min-width:max-content;">`;
        for (let y = maxY; y >= minY; y--) {
            for (let x = minX; x <= maxX; x++) {
                const k = posKey(x,y);
                const tile = w.data[k];
                const cls = ["map-cell"];
                const isPlayer = worldId === player.worldId && x === player.x && y === player.y;
                if (!tile) cls.push("unknown");
                else if (tile.visited) cls.push("visited");
                if (tile?.type === "START") cls.push("start");
                if (tile?.type === "BEACON" && !tile?.cleared) cls.push("beacon");
                const z = zoneForDist(manhattan(x,y));
                if (z.name === "Nguy Hi·ªÉm") cls.push("zone-danger");
                if (z.name === "T·ª≠ Th·∫ßn") cls.push("zone-death");
                if (isPlayer) cls.push("player");
                const label = isPlayer ? "P" : (tile?.type==="START"?"S":(tile?.type==="BEACON"&&!tile?.cleared?"B":""));
                html += `<div class="${cls.join(" ")}" style="height:18px;font-size:10px;" title="${k}">${label}</div>`;
            }
        }
        html += `</div></div>`;
        return html;
    }

    function openWorldMap() {
        getWorld();
        const worldIds = Object.keys(worlds);
        const body = `<div style="text-align:left;">
            <div style="color:#8b949e;font-size:12px;margin-bottom:8px;">B·∫£n ƒë·ªì t·ªïng (c√°c th·∫ø gi·ªõi ƒë√£ m·ªü).</div>
            ${worldIds.map(id => {
                const def = WORLD_DB.find(w => w.id === id);
                return `<details style="margin-bottom:10px;border:1px solid var(--border-color);border-radius:10px;background:#0b0f14;padding:10px;">
                    <summary style="cursor:pointer;color:#c9d1d9;font-weight:800;">üåç ${def?.name || id}</summary>
                    <div style="margin-top:10px;">${renderWorldMap(id)}</div>
                </details>`;
            }).join("")}
        </div>`;
        showModal("B·∫¢N ƒê·ªí T·ªîNG", "", false, body);
        const btn = $("btn-close-modal");
        if (btn) { btn.innerText = "ƒê√≥ng"; btn.onclick = closeModal; }
    }

    function endCombat(win) {
        toggleInput(false);
        if(!win) { setCombatMode(false); return; }
        
        let totalGen = 0, totalMeat = 0, totalMed = 0;

        currentEnemies.forEach(e => {
            if (e.noLoot) return;
            
            // T√¨m trong b·∫£ng loot (ƒê√£ b·ªï sung Boss)
            let table = LOOT_TABLE[e.baseName || e.name] || { meat: 0.5, gen: 10, med: 0.0 };
            
            const meatChance = enemyMeatChanceByHp(e, table.meat);
            if (Math.random() < meatChance) {
                totalMeat += 1;
                // bonus th·ªãt nh·∫π cho qu√°i r·∫•t tr√¢u
                const hp = Number(e?.stats?.maxHp ?? 0);
                if (hp >= 180 && Math.random() < 0.35) totalMeat += 1;
                if (hp >= 280 && Math.random() < 0.25) totalMeat += 1;
            }

            if (Math.random() < table.med) totalMed += 1;

            const genMul = enemyLootFactor(e);
            let gen = Math.floor((table.gen + rand(0, 5)) * genMul);

            // Bonus Trait
            e.traits.forEach(t => {
                if (t.name.includes("Huy·∫øt") || t.name.includes("M√°u")) { if (Math.random() < 0.5) totalMeat += 1; }
                if (t.name.includes("Tinh Th·ªÉ") || t.name.includes("G·ªó") || t.name.includes("S·∫Øt") || t.name.includes("Titan")) gen += 10;
                if (t.name.includes("H·∫°t Nh√¢n") || t.name.includes("V≈© Tr·ª•")) gen += 20;
            });

            totalGen += gen;
        });

        player.genPoints += totalGen;
        player.items.meat += totalMeat;
        player.items.medkit += totalMed;

        // Boss drop: Vi√™n NƒÉng L∆∞·ª£ng (c∆° ch·∫ø ·∫©n)
        const killedBoss = currentEnemies.some(e => e?.isBoss && !e?.noLoot);
        if (killedBoss) {
            player.items.energy += 1;
            player.bossDefeatedOnce = true;
            player.bossKills = (player.bossKills || 0) + 1;
            log(`‚ö° Nh·∫∑t ƒë∆∞·ª£c 1 v·∫≠t ph·∫©m l·∫°.`, "boss");
        }

        let msg = `Th·∫Øng! +${totalGen} Gen`;
        if (totalMeat > 0) msg += `, +${totalMeat} Th·ªãt`;
        if (totalMed > 0) msg += `, +${totalMed} Thu·ªëc`;
        log(msg, "new");

        setCombatMode(false);
        updateUI();
    }

    function startTimeMachine() {
        const d = manhattan(player.x, player.y);
        if (d !== 0) { log("C·∫ßn ƒë·ª©ng t·∫°i (0,0) ƒë·ªÉ thao t√°c C·ªó M√°y Th·ªùi Gian.", "danger"); return; }
        if (player.timeMachineStarted) { log("C·ªó M√°y Th·ªùi Gian ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông.", "info"); return; }
        if ((player.items.energy || 0) < 10) { log("Ch∆∞a ƒë·ªß 10 Vi√™n NƒÉng L∆∞·ª£ng.", "danger"); return; }

        openConfirm({
            title: "C·ªñ M√ÅY TH·ªúI GIAN",
            desc: `B·∫°n mu·ªën n·∫°p <strong style="color:#fff">10 Vi√™n NƒÉng L∆∞·ª£ng</strong> ƒë·ªÉ kh·ªüi ƒë·ªông?<br><br><span style="color:#8b949e;">(Hi·ªán ch∆∞a c√≥ k·∫øt th√∫c/hi·ªáu ·ª©ng cu·ªëi c√πng ‚Äî s·∫Ω b·ªï sung sau.)</span>`,
            yesText: "KH·ªûI ƒê·ªòNG",
            noText: "ƒê·ªÇ SAU",
            onYes: () => {
                player.items.energy -= 10;
                player.timeMachineStarted = true;
                log("‚è≥ C·ªó M√°y Th·ªùi Gian ƒë√£ kh·ªüi ƒë·ªông... nh∆∞ng b·∫°n v·∫´n ch∆∞a bi·∫øt n√≥ s·∫Ω ƒë∆∞a m√¨nh ƒëi ƒë√¢u.", "boss");
                closeModal();
                updateUI();
            },
            onNo: () => { /* kh√¥ng l√†m g√¨ */ }
        });
    }

    function rest() {
        // Ngh·ªâ ng∆°i c≈©ng l√†m th·ªùi gian tr√¥i (1 b∆∞·ªõc)
        advanceTimeSteps(1);
        if (biomeDisableMeat()) { log(`${currentWorldDef().name}: Th·ªãt b·ªã v√¥ hi·ªáu h√≥a ·ªü th·∫ø gi·ªõi n√†y!`, "danger"); updateUI(); return; }
        if (player.items.meat > 0) {
            player.items.meat--;
            const heal = Math.floor(40 * biomeHealMult());
            player.hp = Math.min(player.maxHp, player.hp + heal);
            log(`ƒÇn th·ªãt (+${heal} HP).`, "new");
        } else log("H·∫øt th·ªãt!", "danger");
        updateUI();
    }
    function useMedkit() {
        if (player.items.medkit > 0) {
            player.items.medkit--;
            const heal = Math.floor(70 * biomeHealMult());
            player.hp = Math.min(player.maxHp, player.hp + heal);
            log(`D√πng thu·ªëc (+${heal} HP).`, "new");
        } else log("H·∫øt thu·ªëc!", "danger");
        updateUI();
    }
    function useTablecloth() { if(player.genPoints>=20){player.genPoints-=20;player.items.meat+=2;log("ƒê·ªïi 20 Gen -> 2 Th·ªãt.","new");}else log("C·∫ßn 20 Gen.","danger"); updateUI(); }
    function openEvo() {
        $("modal-title").innerText="S√öNG TI·∫æN H√ìA";
        $("modal-desc").innerText="";
        window.gunRolled = false;
        window.tempOpts = undefined;
        const tabHtml = `
            <div style="display:flex;gap:8px;margin-bottom:10px;">
                <button id="btn-evo-gun" class="evo-option" data-evo-tab="gun">üî´ B·∫Øn Gen (-50 Gen)</button>
                <button id="btn-surgery" class="evo-option" data-evo-tab="surgery">üß™ Tho√°i Ho√° (Ti√™u Tr·ª´ ƒê·∫∑c T√≠nh)</button>
            </div>
            <div id="evo-content"></div>
        `;
        $("modal-body").innerHTML = tabHtml;
        $("btn-close-modal").innerText="ƒê√≥ng";
        $("btn-close-modal").onclick=closeModal;
        $("modal-overlay").classList.remove("hidden");
        $("btn-evo-gun").disabled = false;
        const sbtn = $("btn-surgery"); 
        if (sbtn) sbtn.disabled = false;
    }
    function renderGunOptions(opts) {
        const currentTraitsSection = (() => {
            const traits = (player.traits || []).filter(t => t?.element !== "C∆∞·ªùng Ho√°").map(normTrait);
            if (!traits.length) {
                return `<details style="margin-bottom:10px;border:1px solid var(--border-color);border-radius:8px;background:#0b0f14;padding:10px;">
                    <summary style="cursor:pointer;color:#c9d1d9;font-weight:800;">üß¨ Gen hi·ªán c√≥ (0)</summary>
                    <div style="margin-top:8px;color:#8b949e;font-size:12px;">Ch∆∞a c√≥ ƒë·∫∑c t√≠nh n√†o.</div>
                </details>`;
            }
            const rows = traits.map(t => {
                const st = t.state === "ACTIVE" ? "Hi·ªán" : (t.state || "·∫®n");
                const tt = traitText(t);
                return `<div style="display:flex;gap:8px;align-items:flex-start;justify-content:space-between;border-top:1px dashed #30363d;padding:8px 0;">
                    <div style="min-width:0;">
                        <div style="color:#fff;font-weight:700;line-height:1.2;word-break:break-word;">${traitTagHTML(t)} <span style="color:#8b949e;font-size:12px;">[${t.part}] Lv.${t.level} (${st})</span></div>
                        <div style="margin-top:4px;color:#8b949e;font-size:12px;">${tt.base || ""}${tt.base && tt.inc ? " ‚Ä¢ " : ""}${tt.inc || ""}</div>
                        ${tt.total ? `<div style="margin-top:2px;color:#fff;font-size:12px;"><strong>${tt.total}</strong></div>` : ""}
                    </div>
                </div>`;
            }).join("");
            return `<details style="margin-bottom:10px;border:1px solid var(--border-color);border-radius:8px;background:#0b0f14;padding:10px;">
                <summary style="cursor:pointer;color:#c9d1d9;font-weight:800;">üß¨ Gen hi·ªán c√≥ (${traits.length})</summary>
                <div style="margin-top:8px;">${rows}</div>
                <div style="margin-top:8px;color:#8b949e;font-size:11px;">Tip: b·∫•m v√†o m≈©i t√™n ƒë·ªÉ thu g·ªçn khung n√†y khi mu·ªën t·∫≠p trung ch·ªçn.</div>
            </details>`;
        })();

        const html = opts.map((t,i)=>{
            const isFortify = t?.element === "C∆∞·ªùng Ho√°";
            const hasSame = isFortify ? false : !!findTrait(t.part, t.element);
            const occupied = isFortify ? false : isSlotOccupied(t.part);
            let title = "";
            let mode = isFortify ? "fortify" : "new"; // new | upgrade | replace | fortify
            let target = null;
            if (hasSame) {
                mode = "upgrade";
            } else if (occupied) {
                target = player.traits.find(x => x.part===t.part && x.state==="ACTIVE");
                if (target) {
                    title = ` title="S·∫Ω thay th·∫ø ${target.name} Lv.${target.level}"`;
                }
                mode = "replace";
            }
            normTrait(t);
            if (target) normalizeTraitColor(target);
            const badge =
                mode === "replace" ? `<span class="trait-badge trait-badge-replace">THAY TH·∫æ</span>` :
                mode === "upgrade" ? `<span class="trait-badge trait-badge-upgrade">UP C·∫§P</span>` :
                mode === "fortify" ? `<span class="trait-badge trait-badge-new">C·ªòNG CH·ªà S·ªê</span>` :
                `<span class="trait-badge trait-badge-new">L·∫ÆP M·ªöI</span>`;

            const replaceLine = (mode === "replace" && target)
                ? `<div style="margin-top:6px;color:#8b949e;font-size:12px;">${traitTagHTML(t)} ‚Üí ${traitTagHTML(target)}</div>`
                : "";

            const style = mode === "replace" ? `style="border-color:${t.color}; background:${t.color}33; color:#fff;"` : `style="border-color:${t.color}; background:${t.color}33; color:#fff;"`;
            const tt = traitText(t);
            return `<button class="evo-option" data-mode="${mode}" data-evo-pick="${i}" ${style}${title}>
                <strong>${t.name}</strong> ${badge}<br>
                <small>${t.desc || ""}</small>
                ${tt.base ? `<div style="margin-top:6px;color:#8b949e;font-size:12px;">${tt.base}</div>` : ""}
                ${tt.inc ? `<div style="margin-top:6px;color:#8b949e;font-size:12px;">${tt.inc}</div>` : ""}
                ${tt.total ? `<div style="margin-top:2px;color:#fff;font-size:12px;"><strong>${tt.total}</strong></div>` : ""}
                ${t.passive?`<br><span style="color:#fff">‚òÖ ${t.passive}</span>`:''}
                ${replaceLine}
            </button>`;
        }).join("");
        $("evo-content").innerHTML = currentTraitsSection + html;
    }
    function openEvoGun() {
        if (window.gunRolled) { 
            renderGunOptions(window.tempOpts || []); 
            const btn = $("btn-evo-gun"); 
            if (btn) btn.disabled = true; 
            return; 
        }
        if(player.genPoints<50){ 
            $("evo-content").innerHTML = `<div>Thi·∫øu Gen (c·∫ßn 50).</div>`; 
            return; 
        }
        player.genPoints -= 50;
        updateUI();
        // Trait roll cho ng∆∞·ªùi ch∆°i: scale baseVal theo base stat hi·ªán t·∫°i c·ªßa player
        let opts=[]; for(let i=0;i<3;i++)opts.push(generateSynergyTrait(null, { scaleWithPlayerBase: true }));
        window.tempOpts=opts;
        window.gunRolled = true;
        renderGunOptions(opts);
        const btn = $("btn-evo-gun"); 
        if (btn) btn.disabled = true;
        const sbtn = $("btn-surgery"); 
        if (sbtn) sbtn.disabled = true;
    }
    function openSurgery() {
        if (player.traits.length===0) { $("evo-content").innerHTML = `<div>Ch∆∞a c√≥ gen.</div>`; return; }
        // "C∆∞·ªùng Ho√°" kh√¥ng n·∫±m trong kho gen n√™n kh√¥ng cho ti√™u tr·ª´
        let html = player.traits
            .map((t,idx)=>({t,idx}))
            .filter(x => x?.t?.element !== "C∆∞·ªùng Ho√°")
            .map(x => ({ t: normTrait(x.t), idx: x.idx }))
            .map(({t,idx})=>{
            const st = t.state==="ACTIVE"?"Hi·ªán":"·∫®n";
            return `<div style="border:1px solid var(--border-color);padding:8px;margin-bottom:6px;border-radius:6px;background:#0b0f14;">
                <div>${traitTagHTML(t)} <strong>[${t.part}] Lv.${t.level} (${st})</strong></div>
                <small>${t.desc}</small>
                <button class="evo-option" data-cut-trait="${idx}">Ti√™u Tr·ª´ ƒê·∫∑c T√≠nh</button>
            </div>`;
        }).join("");
        $("evo-content").innerHTML = html;
    }
    function removeTraitByIndex(idx) {
        let t = player.traits[idx];
        ensureTraitScalingFields(t);
        let total = traitTotalVal(t);
        if (t.type === "HP") { player.maxHp -= total; player.hp = Math.min(player.hp, player.maxHp); }
        if (t.type === "ATK") player.atk -= total;
        if (t.type === "DEF") player.def -= total;
        if (t.type === "SPD") player.spd -= total;
        if (t.type === "REGEN") player.regen -= total;
        if (t.state==="ACTIVE") player.slots[t.part]=false;
        player.traits.splice(idx,1);
        updateUI();
    }
    function cutTrait(idx) {
        removeTraitByIndex(idx);
        openSurgery();
    }
    function closeModal() { $("modal-overlay").classList.add("hidden"); }
    function doEvolve(i) {
        let t=window.tempOpts[i];
        // Kh√¥ng ch·∫•p nh·∫≠n trait kh√¥ng c√≥ element (d·ªØ li·ªáu l·ªói)
        if (!t || !t.element) {
            log("L·ªói Gen: ƒë·∫∑c t√≠nh kh√¥ng c√≥ element (kh√¥ng th·ªÉ l·∫Øp).", "danger");
            showModal("L·ªñI GEN", "ƒê·∫∑c t√≠nh ƒë∆∞·ª£c t·∫°o ra b·ªã thi·∫øu element. H√£y th·ª≠ b·∫Øn l·∫°i.", false);
            return;
        }
        ensureTraitScalingFields(t);

        // "C∆∞·ªùng Ho√°": c·ªông th·∫≥ng v√†o ch·ªâ s·ªë g·ªëc, kh√¥ng l∆∞u v√†o kho gen, kh√¥ng xung ƒë·ªôt
        if (t.element === "C∆∞·ªùng Ho√°") {
            applyPermanentFortify(t);
            updateUI();
            closeModal();
            return;
        }

        const existing = findTrait(t.part, t.element);
        if (existing) {
            ensureTraitScalingFields(existing);

            // (B) REGEN: n·∫øu g·∫∑p Mk cao h∆°n, n√¢ng "mk n·ªÅn" c·ªßa trait hi·ªán c√≥
            // - C·∫≠p nh·∫≠t baseVal/name/desc theo Mk m·ªõi
            // - C·ªông ph·∫ßn ch√™nh l·ªách cho to√†n b·ªô level hi·ªán t·∫°i ƒë·ªÉ ch·ªâ s·ªë ph·∫£n √°nh Mk m·ªõi ngay l·∫≠p t·ª©c
            if (existing.type === "REGEN") {
                const newBase = Number(t.baseVal ?? t.val ?? 0);
                const oldBase = Number(existing.baseVal ?? existing.val ?? 0);
                if (newBase > oldBase) {
                    const lvNow = Number(existing.level ?? 1);
                    const diff = newBase - oldBase;
                    const mkBonus = diff * lvNow;

                    existing.baseVal = newBase;
                    existing.name = t.name;
                    existing.desc = t.desc;
                    existing.totalVal = Number(existing.totalVal ?? traitTotalVal(existing)) + mkBonus;
                    // c·ªông ngay v√†o ch·ªâ s·ªë player (REGEN)
                    applyTraitStats(existing, 1, mkBonus);
                    // c·∫≠p nh·∫≠t m√†u/rare theo Mk n·ªÅn m·ªõi
                    normalizeTraitColor(existing);
                }
            }

            existing.level += 1;
            const inc = rollUpgradeIncrement(existing);
            existing.val = inc; // val gi·ªù l√† "tƒÉng g·∫ßn nh·∫•t" (bi·∫øn ƒë·ªông theo l·∫ßn up)
            existing.totalVal = Number(existing.totalVal ?? 0) + inc;
            applyTraitStats(existing, 1, inc);
            if (existing.level >= 5) {
                existing.state = "FUSED";
                player.slots[existing.part] = false;
            }
            log(`Ti·∫øn h√≥a: ${existing.name} Lv.${existing.level} (+${inc}, T·ªïng: ${traitTotalVal(existing)})`,"new");
            updateUI();
            closeModal();
            return;
        }
        if (isSlotOccupied(t.part)) {
            const idx = player.traits.findIndex(x => x.part===t.part && x.state==="ACTIVE");
            if (idx !== -1) {
                log(`Thay th·∫ø: Ti√™u tr·ª´ ${player.traits[idx].name} v√† l·∫Øp ${t.name}.`,"danger");
                removeTraitByIndex(idx);
            }
        }
        // Trait m·ªõi: kh·ªüi t·∫°o field ƒë·ªÉ h·ªó tr·ª£ upgrade random sau n√†y
        ensureTraitScalingFields(t);
        player.traits.push(t);
        player.slots[t.part]=true;
        applyTraitStats(t,1);
        log(`Ti·∫øn h√≥a: ${t.name}`,"new");
        updateUI();
        closeModal();
    }

    function showModal(title, msg, reload=false, customBody="") {
        $("modal-title").innerText = title;
        $("modal-desc").innerText = msg;
        $("modal-body").innerHTML = customBody;
        $("btn-close-modal").innerText = reload ? "Ch∆°i l·∫°i" : "ƒê√≥ng";
        $("btn-close-modal").onclick = reload ? () => location.reload() : closeModal;
        $("modal-overlay").classList.remove("hidden");
    }

    // 1 listener cho c√°c thao t√°c trong modal (evo pick / surgery / combat evo gun)
    $("modal-overlay").addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn || btn.disabled) return;

        if (btn.dataset.confirm) {
            const c = window.__confirm;
            window.__confirm = null;
            if (btn.dataset.confirm === "yes") { c?.onYes?.(); return; }
            if (btn.dataset.confirm === "no") { closeModal(); c?.onNo?.(); return; }
        }

        if (btn.dataset.tele) {
            const wid = btn.dataset.w || player.worldId;
            if (btn.dataset.tele === "home") { teleportTo(wid, 0, 0); closeModal(); return; }
            if (btn.dataset.tele === "random") {
                const keys = visitedKeys(wid).filter(k => k !== "0,0");
                if (!keys.length) { log("Ch∆∞a c√≥ √¥ ƒë√£ gh√© ƒë·ªÉ random.", "danger"); return; }
                const pick = pickRandom(keys);
                const p = parseCoord(pick);
                if (!p) return;
                teleportTo(wid, p.x, p.y);
                closeModal();
                return;
            }
            if (btn.dataset.tele === "go") {
                const input = $("modal-overlay").querySelector("[data-tele-input]");
                const val = input?.value;
                const p = parseCoord(val);
                if (!p) { log("T·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá. Nh·∫≠p d·∫°ng x,y", "danger"); return; }
                teleportTo(wid, p.x, p.y);
                closeModal();
                return;
            }
        }

        if (btn.dataset.world) {
            const id = btn.dataset.world;
            const picked = id === "__RANDOM__"
                ? pickRandom(WORLD_DB.filter(w => w.id !== player.worldId)).id
                : id;
            const def = WORLD_DB.find(w => w.id === picked);
            if (!def) return;
            player.worldId = picked;
            player.x = 0; player.y = 0;
            player.fragments = 0;
            log(`üö™ Du h√†nh t·ªõi ${def.name}. T·ªça ƒë·ªô reset v·ªÅ (0,0).`, "boss");
            closeModal();
    updateUI();
            return;
        }

        // Combat evo gun choice
        if (btn.dataset.cgev) {
            const targetId = Number(btn.dataset.cgev);
            const mode = btn.dataset.mode;
            return combatEvoGunChoose(targetId, mode);
        }

        // Evo tabs
        const tabMap = { gun: openEvoGun, surgery: openSurgery };
        const tab = btn.dataset.evoTab;
        if (tab && tabMap[tab]) return tabMap[tab]();

        // Pick evolve option
        if (btn.dataset.evoPick !== undefined) {
            const idx = Number(btn.dataset.evoPick);
            if (Number.isFinite(idx)) return doEvolve(idx);
        }

        // Cut trait in surgery
        if (btn.dataset.cutTrait !== undefined) {
            const idx = Number(btn.dataset.cutTrait);
            if (Number.isFinite(idx)) return cutTrait(idx);
        }
    });

    $("modal-overlay").addEventListener("change", (e) => {
        const sel = e.target.closest("[data-tele-world]");
        if (!sel) return;
        const id = sel.value;
        if (!worlds[id]) getWorld(); // init n·∫øu c·∫ßn (√≠t nh·∫•t current); c√≤n world kh√°c ch·ªâ init khi ƒë√£ t·ª´ng v√†o
        window.__teleWorld = id;
        // rebuild modal ƒë·ªÉ refresh datalist theo world m·ªõi
        openTeleport();
    });

    updateUI();

    //ƒë·ªìng minh, cƒÉn c·ª©, map
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dora-Survivor: Bio-Warfare</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --text-color: #58a6ff;
            --alert-color: #ff7b72;
            --success-color: #3fb950;
            --border-color: #30363d;
            --panel-bg: #161b22;
            --highlight: #f2cc60;
            --rare: #a371f7;
            --legendary: #ffdd57;
        }
        body { font-family: 'Consolas', 'Courier New', monospace; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 10px; font-size: 14px; user-select: none; }
        .container { max-width: 900px; margin: 0 auto; display: flex; flex-direction: column; gap: 10px; }
        
        .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        @media (max-width: 600px) { .dashboard { grid-template-columns: 1fr; } }

        .box { border: 1px solid var(--border-color); background: var(--panel-bg); padding: 15px; border-radius: 6px; position: relative; }
        h2, h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; color: #fff; font-size: 16px; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .stat-val { font-weight: bold; color: #fff; }
        
        .trait-tag { display: inline-block; background: #238636; color: white; padding: 3px 6px; border-radius: 4px; font-size: 11px; margin-right: 4px; margin-bottom: 4px; border: 1px solid rgba(255,255,255,0.2); }
        
        #log-area { height: 200px; overflow-y: auto; font-size: 13px; color: #8b949e; border: 1px solid var(--border-color); padding: 10px; background: #000; }
        .log-new { color: var(--success-color); }
        .log-danger { color: var(--alert-color); }
        .log-success { color: var(--success-color); }
        .log-boss { color: var(--rare); font-weight: bold; }
        
        .enemy-container { display: flex; gap: 8px; margin-top: 10px; overflow-x: auto; padding-bottom: 5px; }
        .enemy-card { 
            border: 2px solid var(--border-color); padding: 10px; min-width: 140px; border-radius: 6px; background: #2a0a0a; 
            cursor: pointer; transition: 0.2s; position: relative;
        }
        .enemy-card:hover { border-color: #8b949e; }
        .enemy-card.selected { border-color: var(--highlight); background: #3e3820; }
        .enemy-card.boss { border-color: var(--rare); background: #2a0e38; box-shadow: 0 0 10px var(--rare); }
        .enemy-card.dead { opacity: 0.3; pointer-events: none; filter: grayscale(100%); }
        .enemy-name { color: var(--alert-color); font-weight: bold; display: block; margin-bottom: 5px;}
        .enemy-hp-bar { height: 4px; background: #555; margin: 5px 0; border-radius: 2px; }
        .enemy-hp-fill { height: 100%; background: var(--alert-color); width: 100%; transition: width 0.3s; }

        .quest-bar-container { background: #222; height: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #555; }
        .quest-bar-fill { background: var(--highlight); height: 100%; width: 0%; transition: width 0.5s; }

        .action-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        button { background: #21262d; color: #c9d1d9; border: 1px solid var(--border-color); padding: 12px; cursor: pointer; border-radius: 4px; font-weight: bold; }
        button:hover { background: #30363d; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-gadget { color: var(--highlight); border-color: #9e8c43; }
        .btn-gadget:hover { background: #3e3820; }
        
        .hidden { display: none !important; }
        
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: var(--panel-bg); border: 2px solid var(--success-color); padding: 20px; width: 85%; max-width: 500px; text-align: center; max-height: 80vh; overflow-y: auto; }
        .evo-option { display: block; width: 100%; margin: 10px 0; padding: 15px; border: 1px solid var(--success-color); background: #0d1117; color: var(--success-color); cursor: pointer; text-align: left; border-radius: 6px; }
        .evo-option[data-mode="replace"] { border: 2px dashed #ff7b72 !important; background: rgba(255, 123, 114, 0.12) !important; }

        /* Mode badges: NEW / UPGRADE / REPLACE (gi√∫p user nh·∫≠n di·ªán ngay) */
        .trait-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 800;
            letter-spacing: 0.4px;
            border: 1px solid rgba(255,255,255,0.12);
            margin-left: 6px;
            vertical-align: middle;
        }
        .trait-badge-new { color: #3fb950; background: rgba(63,185,80,0.12); border-color: rgba(63,185,80,0.35); }
        .trait-badge-upgrade { color: #f2cc60; background: rgba(242,204,96,0.10); border-color: rgba(242,204,96,0.35); }
        .trait-badge-replace { color: #ff7b72; background: rgba(255,123,114,0.10); border-color: rgba(255,123,114,0.35); }
        .evo-option[data-mode="replace"] { outline: 1px dashed rgba(255,123,114,0.55); }
    </style>
</head>
<body>

<div class="container">
    <div class="box" style="text-align: center; border-color: var(--highlight);">
        <h2 style="color: var(--highlight); margin:0;">DORA-SURVIVOR: BIO-WARFARE</h2>
    </div>

    <div class="dashboard">
        <div class="box">
            <h3>üë§ Ng∆∞·ªùi S·ªëng S√≥t</h3>
            <div class="stat-row"><span>HP:</span> <span class="stat-val" id="p-hp">100/100</span></div>
            <div class="stat-row"><span>ATK:</span> <span class="stat-val" id="p-atk">15</span></div>
            <div class="stat-row"><span>DEF:</span> <span class="stat-val" id="p-def">5</span></div>
            <div class="stat-row"><span>SPD:</span> <span class="stat-val" id="p-spd">10</span></div>
            <div style="margin-top:10px; border-top:1px dashed #555; padding-top:5px;">
                <div class="stat-row"><span>üß¨ Gen:</span> <span class="stat-val" id="p-gen">0</span></div>
                <div class="stat-row"><span>üì¶ Kho:</span> <span class="stat-val" id="p-inventory">Th·ªãt: 2, Thu·ªëc: 1</span></div>
            </div>
            
            <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center;">
                <small>ƒê·∫∑c t√≠nh:</small>
                <button data-ui="showTraits" style="padding: 2px 8px; font-size: 11px; width: auto; background: #222; border: 1px solid #555;">üëÅÔ∏è Chi ti·∫øt</button>
            </div>
            <div id="p-traits" style="margin-top: 5px;">Ch∆∞a c√≥ ƒë·∫∑c t√≠nh</div>
        </div>

        <div class="box">
            <h3>üöÄ Nhi·ªám V·ª•: S·ª≠a C·ªó M√°y</h3>
            <div class="stat-row"><span>üìÖ Ng√†y sinh t·ªìn:</span> <span class="stat-val" id="g-day">1</span></div>
            <div class="stat-row"><span>üß© Linh ki·ªán:</span> <span class="stat-val" id="g-parts">0/5</span></div>
            <div class="quest-bar-container">
                <div class="quest-bar-fill" id="quest-bar"></div>
            </div>
            <p id="next-event" style="font-size: 12px; color: #8b949e; margin-top: 10px;">
                S·ª± ki·ªán ti·∫øp theo: Boss xu·∫•t hi·ªán v√†o Ng√†y 10.
            </p>
            
            <div id="combat-area" class="hidden" style="margin-top: 10px; border-top: 1px solid #333; padding-top:10px;">
                <small style="color: #ff7b72;">‚ö†Ô∏è ƒêANG GIAO CHI·∫æN! (Ch·ªçn m·ª•c ti√™u)</small>
                <div class="enemy-container" id="e-list"></div>
            </div>
        </div>
    </div>

    <div id="log-area">
        <div>> Kh·ªüi ƒë·ªông nh·∫≠t k√Ω sinh t·ªìn...</div>
        <div>> M·ª•c ti√™u: Thu th·∫≠p 5 linh ki·ªán t·ª´ c√°c Boss (xu·∫•t hi·ªán m·ªói 10 ng√†y).</div>
    </div>

    <div class="box">
        <div id="mode-explore" class="action-grid">
            <button data-act="explore">üìÖ TI·∫æN T·ªöI 1 NG√ÄY (Th√°m hi·ªÉm)</button>
            <button data-act="rest">‚õ∫ NGH·ªà NG∆†I (H·ªìi m√°u, ƒÇn th·ªãt)</button>
            <button data-act="useMedkit">üß∞ D√ôNG THU·ªêC (H·ªìi m√°u nhanh)</button>
            <button class="btn-gadget" data-act="useTablecloth">üçΩÔ∏è KHƒÇN TR·∫¢I B√ÄN (Gen -> Th·ªãt)</button>
            <button data-act="openEvo" id="btn-evo" style="grid-column: span 2; border-color: #3fb950; color: #3fb950;">üß¨ D√ôNG S√öNG TI·∫æN H√ìA (50 Gen)</button>
        </div>

        <div id="mode-combat" class="action-grid hidden">
            <button data-perform="basic">‚öîÔ∏è T·∫§N C√îNG TH∆Ø·ªúNG</button>
            <button class="btn-gadget" data-perform="air_cannon">üí• ƒê·∫°i B√°c Kh√¥ng Kh√≠(DMG Cao)</button>
            <button class="btn-gadget" data-perform="dictator_switch">‚ò†Ô∏è C√¥ng T·∫Øc ƒê·ªôc T√†i(X√≥a S·ªï - No Loot)</button>
            <button class="btn-gadget" data-perform="evo_gun_enemy">üî´ S√∫ng Ti·∫øn H√≥a (Debuff/X√≥a trait)</button>
            <button class="btn-gadget" data-perform="counter_mantle">üõë KhƒÉn Cho√†ng A-l√™-h·∫•p (Ch·∫∑n)</button>
            <button class="btn-gadget" data-perform="anywhere_door">üö™ C·ª≠a Th·∫ßn K·ª≥ (Ch·∫°y)</button>
            <button data-perform="use_medkit">üß∞ D√ôNG THU·ªêC </button>
        </div>
    </div>
</div>

<div id="modal-overlay" class="hidden">
    <div class="modal-content">
        <h3 id="modal-title" style="color: #3fb950;">TH√îNG B√ÅO</h3>
        <p id="modal-desc" style="color: #8b949e; font-size: 13px;">N·ªôi dung</p>
        <div id="modal-body"></div>
        <button id="btn-close-modal" style="margin-top:20px; width:100%;">ƒê√≥ng</button>
    </div>
</div>

<script>
    
    /* --- DATA: SINH H·ªåC --- */
    const PARTS_DB = {
        ATK: [
            { name: "Vu·ªët", tag: "MELEE" }, { name: "Nanh", tag: "DRAIN" }, { name: "Gai", tag: "THORNS" }, 
            { name: "ƒêu√¥i", tag: "MELEE" }, { name: "S·ª´ng", tag: "MELEE" }, { name: "X√∫c Tu", tag: "MELEE" }
        ],
        DEF: [
            { name: "Da", tag: "SKIN" }, { name: "V·ªè", tag: "ARMOR" }, { name: "X∆∞∆°ng", tag: "SKELETON" }, { name: "V·∫£y", tag: "ARMOR" }
        ],
        HP:  [
            { name: "Tim", tag: "CORE" }, { name: "M√°u", tag: "FLUID" }, { name: "T·∫ø B√†o", tag: "CELL" }
        ],
        SPD: [
            { name: "C√°nh", tag: "FLIGHT" }, { name: "Ch√¢n", tag: "MOVE" }, { name: "M·∫Øt", tag: "SIGHT" }
        ]
    };

    const TIERS_DB = [
        { name: "C∆∞·ªùng Ho√°", mod: 1.0, rare: 1, element: "NONE" }, 
        { name: "G·ªó H√≥a", mod: 1.1, rare: 2, element: "HARD" },
        { name: "L·ª≠a", mod: 1.3, rare: 2, element: "FIRE" },   
        { name: "BƒÉng", mod: 1.3, rare: 2, element: "ICE" },   
        { name: "ƒê·ªôc", mod: 1.2, rare: 2, element: "POISON" }, 
        { name: "Huy·∫øt", mod: 1.4, rare: 3, element: "BLOOD" },
        { name: "Tinh Th·ªÉ", mod: 1.8, rare: 3, element: "HARD" }, 
        { name: "H·∫°t Nh√¢n", mod: 2.2, rare: 4, element: "RADIOACTIVE" }, 
        { name: "H∆∞ Kh√¥ng", mod: 2.5, rare: 4, element: "VOID" },
        { name: "V≈© Tr·ª•", mod: 3.0, rare: 5, element: "COSMIC" }
    ];

    const ENTITIES = ["Zombie", "Chu·ªôt", "Gi√°n", "S√≥i", "Ng∆∞·ªùi M√°y", "C√¢y ƒê·ªôt Bi·∫øn", "Th·∫±n L·∫±n"];
    const BOSS_NAMES = ["Kh·ªïng L·ªì M·ªôt M·∫Øt", "B·∫°ch Tu·ªôc Kh√¥ng Gian", "M√°y Ch√©m R·ªâ S√©t", "S√≥i Alpha ƒê·ªôt Bi·∫øn"];
    const FINAL_BOSS = "VUA H·ª¶Y DI·ªÜT";
    const BODY_PARTS = ["Vu·ªët","Nanh","Gai","ƒêu√¥i","S·ª´ng","X√∫c Tu","Da","V·ªè","X∆∞∆°ng","V·∫£y","Tim","M√°u","T·∫ø B√†o","C√°nh","Ch√¢n","M·∫Øt"];

    // --- C·∫¨P NH·∫¨T: Th√™m Boss v√†o Loot Table ƒë·ªÉ th∆∞·ªüng to h∆°n ---
    const LOOT_TABLE = {
        "Zombie": { meat: 0.8, gen: 10, med: 0.05 },
        "Chu·ªôt":  { meat: 0.7, gen: 5,  med: 0.05 },
        "Gi√°n":   { meat: 0.2, gen: 5,  med: 0.05 },
        "S√≥i":    { meat: 1.0, gen: 15, med: 0.0 },
        "Th·∫±n L·∫±n": { meat: 0.9, gen: 10, med: 0.0 },
        "Ng∆∞·ªùi M√°y": { meat: 0.0, gen: 40, med: 0.1 }, 
        "C√¢y ƒê·ªôt Bi·∫øn": { meat: 0.1, gen: 10, med: 0.4 },
        
        // --- Th√™m BOSS ---
        "Kh·ªïng L·ªì M·ªôt M·∫Øt": { meat: 1.0, gen: 100, med: 0.3 },
        "B·∫°ch Tu·ªôc Kh√¥ng Gian": { meat: 1.0, gen: 120, med: 0.3 },
        "M√°y Ch√©m R·ªâ S√©t": { meat: 0.0, gen: 150, med: 0.3 }, // Nhi·ªÅu Gen
        "S√≥i Alpha ƒê·ªôt Bi·∫øn": { meat: 1.0, gen: 120, med: 0.3 },
        "VUA H·ª¶Y DI·ªÜT": { meat: 1.0, gen: 500, med: 1.0 } // Tr√πm cu·ªëi
    };

    let player = {
        hp: 100, maxHp: 100, atk: 15, def: 5, spd: 10, regen: 0, 
        genPoints: 0, items: { meat: 3, medkit: 1 }, 
        traits: [], days: 1, parts: 0, slots: {}
    };
    BODY_PARTS.forEach(p => player.slots[p] = false);

    let currentEnemies = [];
    let isCountering = false;
    let isBossFight = false;

    /* --- UTILITIES --- */
    const $ = (id) => document.getElementById(id);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

    const LOG_CLASS = { danger: "log-danger", new: "log-new", success: "log-success", boss: "log-boss", info: "log-info" };
    const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const pickRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];

    function log(msg, type = "info") {
        const div = $("log-area");
        div.insertAdjacentHTML("beforeend", `<div class="${LOG_CLASS[type] || LOG_CLASS.info}">> ${msg}</div>`);
        div.scrollTop = div.scrollHeight;
    }

    function qualityColor(q){ if(q>=5) return "#ff00aa"; if(q===4) return "#ffdd57"; if(q===3) return "#a371f7"; if(q===2) return "#58a6ff"; return "#3fb950"; }
    
    function toggleInput(disabled) {
        $$('#mode-combat button').forEach(btn => {
            btn.disabled = disabled;
            btn.style.opacity = disabled ? "0.5" : "1";
            btn.style.cursor = disabled ? "not-allowed" : "pointer";
        });
    }

    function setCombatMode(on) {
        $("mode-explore").classList.toggle("hidden", on);
        $("mode-combat").classList.toggle("hidden", !on);
        $("combat-area").classList.toggle("hidden", !on);
    }

    // 1 listener cho to√†n b·ªô UI button (g·ªçn h∆°n onclick r·∫£i r√°c)
    document.addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn) return;
        if (btn.disabled) return;

        if (btn.dataset.ui === "showTraits") return showTraits();

        const actMap = { explore, rest, useMedkit, useTablecloth, openEvo };
        const act = btn.dataset.act;
        if (act && actMap[act]) return actMap[act]();

        const perf = btn.dataset.perform;
        if (perf) return performAction(perf);
    });

    /* --- TRAIT GENERATOR --- */
    function generateSynergyTrait(forceTier = null) {
        const TYPES = ["ATK","DEF","HP","SPD","REGEN"]; 
        let type = TYPES[rand(0, TYPES.length-1)];

        let desc = "", finalVal = 0, passive = null, fullName = "";
        // elementName: invariant b·∫Øt bu·ªôc ph·∫£i c√≥ ƒë·ªÉ map m√†u/ƒë·ªô hi·∫øm ·ªïn ƒë·ªãnh
        let elementName = "";
        let rare = 1;
        // partName: d√πng tr·ª±c ti·∫øp t√™n b·ªô ph·∫≠n (KH√îNG parse t·ª´ name ƒë·ªÉ tr√°nh l·ªói b·ªô ph·∫≠n 2 ch·ªØ)
        let partName = "";

        if (type === "REGEN") {
            let val = 4;
            let rareMod = rand(1, 3);
            finalVal = val * rareMod;
            fullName = "T·∫ø B√†o T√°i Sinh" + (rareMod > 1 ? ` Mk.${rareMod}` : "");
            desc = `H·ªìi ${finalVal} HP/l∆∞·ª£t`;
            elementName = "REGEN";
            rare = Math.min(3, Math.max(1, Math.round(finalVal/4)));
            // REGEN g·∫Øn v·ªõi slot "T·∫ø B√†o"
            partName = "T·∫ø B√†o";
        } else {
            let partList = PARTS_DB[type];
            let part = partList[Math.floor(Math.random() * partList.length)];
            partName = part.name;

            let tierList;
            if (forceTier) {
                tierList = [forceTier];
            } else {
                const rares = [1,2,3,4,5];
                const chosenRare = rares[rand(0, rares.length-1)];
                tierList = TIERS_DB.filter(t => t.rare === chosenRare);
                if (tierList.length === 0) tierList = TIERS_DB;
            }
            let prefix = pickRandom(tierList);
            // Kh√¥ng suy ra element b·∫±ng c√°ch c·∫Øt chu·ªói t·ª´ name n·ªØa (d·ªÖ sai khi name c√≥ suffix).
            // Element lu√¥n ch√≠nh l√† tier.name (v√≠ d·ª•: "C∆∞·ªùng Ho√°", "H·∫°t Nh√¢n", "V≈© Tr·ª•"...)
            elementName = prefix.name;
            rare = prefix.rare;

            let baseVal = (type==="HP"?20 : type==="ATK"?8 : 5);
            
            if (prefix.name === "C∆∞·ªùng Ho√°") {
                let bonusPercent = rand(1, 15);
                finalVal = Math.floor(baseVal * (1 + bonusPercent/100));
                if (finalVal <= baseVal) finalVal = baseVal + 1; 
                desc = `${type} +${finalVal} (C∆∞·ªùng ho√° ${bonusPercent}%)`;
            } else {
                finalVal = Math.floor(baseVal * prefix.mod * ((Math.random()*0.4)+0.8));
                desc = `${type} +${finalVal}`;
            }
            finalVal = Math.max(1, finalVal);

            let passiveDesc = "";
            if (prefix.element === "FIRE" && part.tag === "MELEE") { passive = "BURN"; passiveDesc = " (Ch√°y +5 DMG)"; }
            else if (prefix.element === "BLOOD" && part.tag === "DRAIN") { passive = "LIFESTEAL"; passiveDesc = " (H√∫t 20% HP)"; }
            else if (prefix.element === "POISON" && (part.tag === "THORNS" || part.tag === "SKIN")) { passive = "POISON_SKIN"; passiveDesc = " (Ph·∫£n ƒë·ªôc)"; }
            else if (prefix.element === "VOID" && type === "ATK") { passive = "PIERCE"; passiveDesc = " (Xuy√™n 50% Gi√°p)"; }
            else if (prefix.element === "RADIOACTIVE" && part.tag === "CORE") { passive = "REACTOR"; passiveDesc = " (H·ªìi Gen, Tr·ª´ M√°u)"; }
            else if (prefix.element === "ICE" && type === "SPD") { passive = "FREEZE_AURA"; passiveDesc = " (Gi·∫£m T·ªëc ƒê·ªãch)"; }

            fullName = `${part.name} ${prefix.name}`;
            desc += passiveDesc;
        }

        // elementName ph·∫£i lu√¥n c√≥; n·∫øu kh√¥ng c√≥ th√¨ coi l√† l·ªói d·ªØ li·ªáu (kh√¥ng ch·∫•p nh·∫≠n trait "m√π element")
        if (!elementName) {
            throw new Error(`Trait missing element: name="${fullName}", type="${type}"`);
        }
        let color = qualityColor(rare);
        // baseVal: gi√° tr·ªã g·ªëc (Lv.1) d√πng ƒë·ªÉ roll upgrade; val: tƒÉng g·∫ßn nh·∫•t; totalVal: t·ªïng c·ªông d·ªìn th·ª±c t·∫ø
        return { name: fullName, type: type, baseVal: finalVal, val: finalVal, totalVal: finalVal, desc: desc, passive: passive, part: partName, element: elementName, level: 1, state: "ACTIVE", rare: rare, color: color };
    }

    function isSlotOccupied(part) {
        return player.traits.some(t => t.part === part && t.state === "ACTIVE");
    }
    function findTrait(part, element) {
        return player.traits.find(t => t.part === part && t.element === element);
    }
    function normalizeTraitColor(t) {
        if (!t) return t;
        let rare = 1;
        const elementName = t.element;
        // Invariant: trait h·ª£p l·ªá ph·∫£i c√≥ element. Kh√¥ng t·ª± ƒëo√°n t·ª´ t√™n n·ªØa ƒë·ªÉ tr√°nh sai khi name c√≥ suffix.
        if (!elementName) {
            console.warn("Trait missing element (cannot normalize color reliably):", t);
            // Gi·ªØ m√†u m·∫∑c ƒë·ªãnh ƒë·ªÉ kh√¥ng ph√° UI, nh∆∞ng ƒë√¢y l√† d·ªØ li·ªáu l·ªói.
            t.rare = 1;
            t.color = qualityColor(1);
            return t;
        }
        // T√¨m tier theo name ho·∫∑c element
        let tier = TIERS_DB.find(x => x.name === elementName || x.element === elementName);
        if (tier) {
            rare = tier.rare;
        } else if (t.type === "REGEN") {
            rare = Math.min(3, Math.max(1, Math.round((t.val||4)/4)));
        }
        // Lu√¥n c·∫≠p nh·∫≠t l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o m√†u ƒë√∫ng
        t.rare = rare;
        t.color = qualityColor(rare);
        return t;
    }

    const normTrait = (t) => ensureTraitScalingFields(normalizeTraitColor(t));
    const traitTagsHTML = (traits) => (traits?.length ? traits.map(normTrait).map(traitTagHTML).join("") : "");

    function traitTotalVal(t) {
        const total = Number(t?.totalVal);
        if (Number.isFinite(total)) return total;
        // Back-compat: phi√™n b·∫£n c≈© d√πng val * level (val c·ªë ƒë·ªãnh theo trait)
        const perLevel = Number(t?.val ?? 0);
        const lv = Number(t?.level ?? 1);
        return perLevel * lv;
    }
    function traitText(t) {
        // Chu·∫©n ho√° text hi·ªÉn th·ªã c·ªßa trait ·ªü 1 ch·ªó duy nh·∫•t (g·ªçn v√† tr√°nh g·ªçi l·∫∑p)
        if (!t) return { base: "", inc: "", total: "", title: "" };
        ensureTraitScalingFields(t);
        const lv = Number(t.level ?? 1);
        const baseVal = Number(t.baseVal ?? 0);
        const incVal = Number(t.val ?? 0); // tƒÉng g·∫ßn nh·∫•t
        const totalVal = Number(traitTotalVal(t) ?? 0);

        const fmt = (v) => {
            if (!v) return "";
            if (t.type === "REGEN") return `H·ªìi ${v} HP/l∆∞·ª£t`;
            if (t.type === "HP") return `HP +${v}`;
            return `${t.type} +${v}`;
        };

        const base = baseVal ? `G·ªëc: ${fmt(baseVal)}` : "";
        const inc = incVal ? `TƒÉng g·∫ßn nh·∫•t (Lv.${lv}): ${fmt(incVal)}` : "";
        const total = totalVal ? `T·ªïng (Lv.${lv}): ${fmt(totalVal)}` : "";

        const lines = [];
        if (t.desc) lines.push(String(t.desc));
        if (base) lines.push(base);
        if (inc) lines.push(inc);
        if (total) lines.push(total);
        return { base, inc, total, title: lines.join("&#10;") };
    }

    function ensureTraitScalingFields(t) {
        if (!t) return t;
        // baseVal: gi√° tr·ªã g·ªëc ƒë·ªÉ roll upgrade quanh n√≥
        if (t.baseVal === undefined || t.baseVal === null) {
            t.baseVal = Number(t.val ?? 0);
        }
        // totalVal: t·ªïng c·ªông d·ªìn th·ª±c t·∫ø (ƒë·ªÉ remove/hi·ªÉn th·ªã ƒë√∫ng)
        if (t.totalVal === undefined || t.totalVal === null) {
            const lv = Number(t.level ?? 1);
            const per = Number(t.val ?? 0);
            // Back-compat: tr∆∞·ªõc ƒë√¢y m·ªói c·∫•p c·ªông ƒë√∫ng per (kh√¥ng random)
            t.totalVal = per * lv;
        }
        return t;
    }

    function rollUpgradeIncrement(t) {
        // Roll tƒÉng ch·ªâ s·ªë cho l·∫ßn n√¢ng c·∫•p m·ªõi quanh baseVal.
        // C√≥ th·ªÉ ch·ªânh bi√™n ƒë·ªô t·∫°i ƒë√¢y ƒë·ªÉ game "g·∫Øt" h∆°n / ·ªïn ƒë·ªãnh h∆°n.
        ensureTraitScalingFields(t);
        const base = Math.max(1, Number(t.baseVal ?? 1));
        const minF = 0.75;
        const maxF = 1.35;
        const f = minF + Math.random() * (maxF - minF);
        let inc = Math.max(1, Math.round(base * f));
        // HP th∆∞·ªùng to h∆°n, tr√°nh l√™n qu√° nh·ªè g√¢y c·∫£m gi√°c "fail roll"
        if (t.type === "HP") inc = Math.max(3, inc);
        return inc;
    }

    function traitTagHTML(t, extra = {}) {
        const title = (extra.title ?? traitText(t).title ?? "").replaceAll('"', "&quot;");
        const name = (extra.name ?? t.name ?? "").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
        const color = t.color || '#3fb950';
        const bg = `${color}33`;
        return `<span class="trait-tag" style="border-color: ${color}; background: ${bg}; color: #ffffff;" title="${title}">${name}</span>`;
    }
    function applyTraitStats(t, factor, deltaOverride = null) {
        const delta = (deltaOverride === null || deltaOverride === undefined)
            ? (Number(t?.val ?? 0) * factor)
            : (Number(deltaOverride) * factor);
        if (t.type === "HP") { player.maxHp += delta; player.hp = Math.min(player.hp + delta, player.maxHp); }
        if (t.type === "ATK") player.atk += delta;
        if (t.type === "DEF") player.def += delta;
        if (t.type === "SPD") player.spd += delta;
        if (t.type === "REGEN") player.regen += delta;
    }

    /* --- UI UPDATE --- */
    function updateUI() {
        $("p-hp").innerText = `${Math.max(0, player.hp)}/${player.maxHp}`;
        $("p-atk").innerText = player.atk;
        $("p-def").innerText = player.def;
        $("p-spd").innerText = player.spd;
        $("p-gen").innerText = player.genPoints;
        $("p-inventory").innerText = `Th·ªãt: ${player.items.meat}, Thu·ªëc: ${player.items.medkit}`;
        
        $("p-traits").innerHTML = traitTagsHTML(player.traits) || "Kh√¥ng";
        
        $("g-day").innerText = player.days;
        $("g-parts").innerText = `${player.parts}/5`;
        $("quest-bar").style.width = `${(player.parts/5)*100}%`;
        
        let nextBossDay = Math.ceil(player.days / 10) * 10;
        if (player.days % 10 === 0 && !isBossFight) nextBossDay += 10; 
        $("next-event").innerText = `M·ª•c ti√™u k·∫ø ti·∫øp: Ng√†y ${nextBossDay} (C√≤n ${nextBossDay - player.days} ng√†y)`;

        $("btn-evo").disabled = player.genPoints < 50;

        if (player.hp <= 0) {
            toggleInput(true); 
            showModal("B·∫†N ƒê√É T·ª¨ N·∫†N", "Th·∫ø gi·ªõi n√†y qu√° kh·∫Øc nghi·ªát. H√£y th·ª≠ l·∫°i.", true);
        }
    }

    function showTraits() {
        if (player.traits.length === 0) { showModal("H·ªí S∆† GEN", "Ch∆∞a c√≥ ƒë·∫∑c t√≠nh."); return; }
        let html = `<div style="text-align: left;">`;
        player.traits.map(normTrait).forEach((t) => {
            let st = t.state === "ACTIVE" ? "Hi·ªán" : "·∫®n";
            const tt = traitText(t);
            html += `<div style="border:1px solid var(--border-color);padding:8px;margin-bottom:6px;border-radius:6px;background:#0b0f14;">
                <div style="color:#fff;font-weight:bold">${traitTagHTML(t)} [${t.part}] Lv.${t.level} (${st})</div>
                <div style="font-size:12px;color:#ccc">${t.desc || ""}</div>
                ${tt.base ? `<div style="font-size:12px;color:#8b949e;margin-top:4px;">${tt.base}</div>` : ""}
                ${tt.inc ? `<div style="font-size:12px;color:#8b949e;margin-top:4px;">${tt.inc}</div>` : ""}
                ${tt.total ? `<div style="font-size:12px;color:#fff;margin-top:2px;"><strong>${tt.total}</strong></div>` : ""}
            </div>`;
        });
        html += `</div>`;
        showModal(`H·ªí S∆† GEN (T·ªïng: ${player.traits.length})`, "", false, html);
    }

    /* --- GAME LOOP --- */
    function explore() {
        if (player.items.meat <= 0 && player.hp < 20) { log("Qu√° ƒë√≥i v√† y·∫øu!", "danger"); return; }
        if (player.days % 10 === 0) { startCombat(true); return; }
        player.hp = Math.max(1, player.hp - 2); player.days++; updateUI();
        if (Math.random() > 0.35) startCombat(false); else findLoot();
    }
    function findLoot() {
        let r = rand(1, 100);
        if (r < 50) { player.items.meat += 2; log("T√¨m th·∫•y 2 Th·ªãt bi·∫øn d·ªã.", "new"); }
        else if (r < 80) { player.genPoints += 25; log("H·∫•p th·ª• ƒë∆∞·ª£c 25 Gen t·ª± do.", "new"); }
        else { player.items.medkit += 1; log("Tuy·ªát v·ªùi! T√¨m th·∫•y 1 H·ªôp C·ª©u Th∆∞∆°ng.", "new"); }
        updateUI();
    }

    /* --- COMBAT SYSTEM --- */
    function startCombat(bossMode) {
        isBossFight = bossMode; currentEnemies = []; isCountering = false; 
        if (bossMode) {
            let bossName = player.parts === 4 ? FINAL_BOSS : pickRandom(BOSS_NAMES);
            let m = 1.5 + (player.days / 20);
            let traits = []; for(let i=0; i<3; i++) traits.push(generateSynergyTrait(pickRandom(TIERS_DB.filter(t=>t.rare>=3))));
            currentEnemies.push({ id: 0, name: bossName, isBoss: true, stats: { hp: Math.floor(150*m), maxHp: Math.floor(150*m), atk: Math.floor(20*m), def: Math.floor(5*m), spd: Math.floor(8*m) }, traits: traits, alive: true, selected: false });
            log(`üî•üî• B√ÅO ƒê·ªòNG: ${bossName} XU·∫§T HI·ªÜN!`, "boss");
        } else {
            let count = rand(1, 3);
            for(let i=0; i<count; i++) {
                let m = 1 + (player.days / 50);
                let traits = []; let tc = rand(1, 2); for(let k=0; k<tc; k++) traits.push(generateSynergyTrait());
                let base = { hp: 40*m, maxHp: 40*m, atk: 10*m, def: 0, spd: 5 };
                traits.forEach(t => { if(t.type==="HP"){base.hp+=t.val;base.maxHp+=t.val;} if(t.type==="ATK")base.atk+=t.val; if(t.type==="DEF")base.def+=t.val; if(t.type==="SPD")base.spd+=t.val; });
                
                let name = pickRandom(ENTITIES);
                currentEnemies.push({ id: i, name: name, isBoss: false, stats: base, traits: traits, alive: true, selected: false });
            }
            log(`Ph√°t hi·ªán ${count} k·∫ª ƒë·ªãch ch·∫∑n ƒë∆∞·ªùng.`);
        }
        setCombatMode(true);
        toggleInput(false); renderEnemies();
    }
    function renderEnemies() {
        const div = $("e-list"); div.innerHTML = "";
        currentEnemies.forEach(e => {
            let hpPct = (e.stats.hp / e.stats.maxHp) * 100;
            let el = document.createElement("div");
            el.className = `enemy-card ${e.isBoss ? 'boss' : ''} ${e.alive ? '' : 'dead'} ${e.selected ? 'selected' : ''}`;
            el.onclick = () => { if(e.alive) { currentEnemies.forEach(x => x.selected = false); e.selected = true; renderEnemies(); } };
            el.innerHTML = `<span class="enemy-name">${e.name}</span><div class="enemy-hp-bar"><div class="enemy-hp-fill" style="width:${hpPct}%"></div></div><small>HP: ${Math.ceil(e.stats.hp)} | ATK: ${Math.ceil(e.stats.atk)}</small><br><div style="margin-top:4px;">${traitTagsHTML(e.traits)}</div>`;
            div.appendChild(el);
        });
    }

    function openCombatEvoGunChoice(targetId) {
        const target = currentEnemies.find(x => x.id === targetId);
        if (!target || !target.alive) {
            log("M·ª•c ti√™u kh√¥ng h·ª£p l·ªá.", "danger");
            toggleInput(false);
            return;
        }
        const body = `
            <div style="text-align:left;">
                <div style="color:#8b949e;font-size:12px;margin-bottom:10px;">Ch·ªçn ch·∫ø ƒë·ªô b·∫Øn l√™n <strong style="color:#fff">${target.name}</strong>:</div>
                <button class="evo-option" data-cgev="${targetId}" data-mode="debuff">üß™ Tho√°i h√≥a (Gi·∫£m ch·ªâ s·ªë)</button>
                <button class="evo-option" data-cgev="${targetId}" data-mode="cleanse">üß¨ T·∫©y Gen (X√≥a 1 ƒë·∫∑c t√≠nh c·ªßa ƒë·ªãch)</button>
                <div style="margin-top:10px;color:#8b949e;font-size:11px;">H·ªßy s·∫Ω kh√¥ng m·∫•t l∆∞·ª£t.</div>
            </div>
        `;
        // Khi m·ªü modal ch·ªçn, t·∫°m th·ªùi kh√¥ng cho thao t√°c kh√°c; n·∫øu h·ªßy th√¨ tr·∫£ l·∫°i l∆∞·ª£t
        showModal("S√öNG TI·∫æN H√ìA", "", false, body);
        const btn = $("btn-close-modal");
        if (btn) {
            btn.innerText = "H·ªßy";
            btn.onclick = () => { closeModal(); toggleInput(false); };
        }
    }

    function combatEvoGunChoose(targetId, mode) {
        const t = currentEnemies.find(x => x.id === targetId);
        if (!t || !t.alive) {
            closeModal();
            log("M·ª•c ti√™u kh√¥ng c√≤n s·ªëng.", "danger");
            toggleInput(false);
            return;
        }

        closeModal();

        if (mode === "debuff") {
            t.stats.atk = Math.floor(t.stats.atk * 0.6);
            t.stats.def = Math.floor(t.stats.def * 0.6);
            t.stats.hp -= 15;
            log(`Tho√°i h√≥a ${t.name}: Ch·ªâ s·ªë gi·∫£m m·∫°nh!`);
        } else if (mode === "cleanse") {
            if (t.traits.length > 0) {
                let ridx = rand(0, t.traits.length - 1);
                let removed = t.traits.splice(ridx, 1)[0];
                const removedTotal = Number(removed?.totalVal ?? removed?.val ?? 0);
                if (removed.type === "ATK") t.stats.atk -= removedTotal;
                if (removed.type === "DEF") t.stats.def -= removedTotal;
                if (removed.type === "HP") {
                    t.stats.maxHp -= removedTotal;
                    t.stats.hp = Math.min(t.stats.hp, t.stats.maxHp);
                }
                if (removed.type === "SPD") t.stats.spd -= removedTotal;
                log(`T·∫©y Gen ${t.name}: M·∫•t ƒë·∫∑c t√≠nh [${removed.name}]!`, "success");
            } else {
                log(`${t.name} kh√¥ng c√≤n Gen n√†o ƒë·ªÉ x√≥a!`, "danger");
            }
        } else {
            // mode kh√¥ng h·ª£p l·ªá -> kh√¥ng m·∫•t l∆∞·ª£t
            log("Ch·∫ø ƒë·ªô kh√¥ng h·ª£p l·ªá.", "danger");
            toggleInput(false);
            return;
        }

        // K·∫øt th√∫c l∆∞·ª£t c·ªßa ng∆∞·ªùi ch∆°i
        currentEnemies.forEach(e => { if (e.stats.hp <= 0) e.alive = false; });
        renderEnemies();
        updateUI();
        if (currentEnemies.every(e => !e.alive)) endCombat(true);
        else setTimeout(enemiesTurn, 500);
    }

    const ACTIONS = {
        counter_mantle: {
            needsTarget: false,
            run: () => { isCountering = true; log("Tung KhƒÉn Cho√†ng A-l√™-h·∫•p!", "info"); setTimeout(enemiesTurn, 500); return { handled: true }; }
        },
        use_medkit: {
            needsTarget: false,
            run: () => {
                if (player.items.medkit <= 0) { log("H·∫øt thu·ªëc! Kh√¥ng th·ªÉ d√πng trong chi·∫øn ƒë·∫•u.", "danger"); toggleInput(false); return { handled: true }; }
                player.items.medkit--;
                const before = player.hp;
                player.hp = Math.min(player.maxHp, player.hp + 70);
                log(`D√πng thu·ªëc trong chi·∫øn ƒë·∫•u (+${player.hp - before} HP).`, "new");
                updateUI();
                setTimeout(enemiesTurn, 500);
                return { handled: true };
            }
        },
        anywhere_door: { needsTarget: false, run: () => { log("M·ªü C·ª≠a Th·∫ßn K·ª≥... Ch·∫°y tho√°t th√†nh c√¥ng!", "info"); endCombat(false); return { handled: true }; } },
        evo_gun_enemy: { needsTarget: true, run: (t) => { openCombatEvoGunChoice(t.id); return { handled: true }; } },
        dictator_switch: {
            needsTarget: true,
            run: (t) => {
                if (t.isBoss) { log("Boss mi·ªÖn nhi·ªÖm!", "danger"); return { handled: true }; }
                if (!confirm("X√≥a s·ªï (Kh√¥ng Loot)?")) { toggleInput(false); return { handled: true }; }
                t.stats.hp = 0; t.noLoot = true; log(`${t.name} b·ªã x√≥a s·ªï.`, "danger");
            }
        },
        air_cannon: { needsTarget: true, run: (t) => { const dmg = Math.max(1, player.atk - t.stats.def); t.stats.hp -= (Math.floor(dmg * 2.5) + 20); log(`ƒê·∫°i b√°c b·∫Øn ${t.name}: ST l·ªõn!`); } },
        basic: {
            needsTarget: true,
            run: (t) => {
                let dmg = Math.max(1, player.atk - t.stats.def);
                if (player.traits.some(x => x.passive === "PIERCE")) { dmg = Math.max(1, player.atk - (t.stats.def / 2)); log("Xuy√™n Gi√°p!", "success"); }
                if (player.traits.some(x => x.passive === "BURN")) { dmg += 5; log("Thi√™u ƒë·ªët +5 DMG!", "danger"); }
                if (player.traits.some(x => x.passive === "LIFESTEAL")) { let h = Math.ceil(dmg * 0.2); player.hp = Math.min(player.maxHp, player.hp + h); log(`H√∫t ${h} HP!`, "new"); }
                t.stats.hp -= dmg; log(`T·∫•n c√¥ng ${t.name}: ${Math.floor(dmg)} ST.`);
            }
        }
    };

    function resolveEndOfPlayerTurn() {
        currentEnemies.forEach(e => { if (e.stats.hp <= 0) e.alive = false; });
        renderEnemies();
        if (currentEnemies.every(e => !e.alive)) endCombat(true);
        else setTimeout(enemiesTurn, 500);
    }

    function getSelectedTarget() {
        let targets = currentEnemies.filter(e => e.selected && e.alive);
        if (targets.length === 0 && currentEnemies.filter(e => e.alive).length === 1) targets = [currentEnemies.find(e => e.alive)];
        return targets[0] || null;
    }

    function performAction(type) {
        const action = ACTIONS[type];
        if (!action) { log("H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá!", "danger"); return; }
        const target = getSelectedTarget();
        if (action.needsTarget && !target) { log("H√£y ch·ªçn m·ª•c ti√™u!", "danger"); return; }

        toggleInput(true);
        const res = action.run(target);
        if (res?.handled) return;
        resolveEndOfPlayerTurn();
    }

    function enemiesTurn() {
        if(currentEnemies.every(e=>!e.alive)) { endCombat(true); return; }
        log("--- L∆∞·ª£t k·∫ª ƒë·ªãch ---", "info");
        let totalDmg = 0;
        currentEnemies.forEach(e => {
            if (e.alive) {
                if (isCountering) { let r = Math.floor(e.stats.atk*1.5); e.stats.hp-=r; log(`‚ú® A-l√™-h·∫•p! ƒê√≤n c·ªßa ${e.name} b·ªã h·∫•t ng∆∞·ª£c l·∫°i (${r} ST)!`,"success"); }
                else {
                    let d = Math.max(1, e.stats.atk - player.def);
                    let chance = (player.spd - e.stats.spd)*2;
                    if(player.traits.some(x=>x.passive==="FREEZE_AURA")) chance+=10;
                    if(Math.random()*100 < chance) log(`N√© ƒë∆∞·ª£c ƒë√≤n c·ªßa ${e.name}!`,"success");
                    else { 
                        if(player.traits.some(x=>x.passive==="POISON_SKIN")){e.stats.hp-=3;log(`${e.name} tr√∫ng ƒë·ªôc (-3 HP)`,"success");}
                        totalDmg+=d; log(`${e.name} g√¢y ${d} ST!`,"danger"); 
                    }
                }
            }
        });
        if(!isCountering) player.hp-=totalDmg; isCountering=false;
        if (player.hp <= 0) { log("‚ò†Ô∏è B·∫°n ƒë√£ g·ª•c ng√£...", "danger"); updateUI(); return; }
        if(player.traits.some(x=>x.passive==="REACTOR")){player.genPoints+=5;player.hp-=2;log("Tim H·∫°t Nh√¢n: +5 Gen, -2 HP","boss"); if(player.hp<=0){updateUI();return;}}
        currentEnemies.forEach(e => { if(e.stats.hp<=0) e.alive=false; }); renderEnemies(); updateUI();
        if(currentEnemies.every(e=>!e.alive)) endCombat(true); else toggleInput(false);
    }

    function endCombat(win) {
        toggleInput(false);
        if(!win) { setCombatMode(false); return; }
        
        let totalGen = 0, totalMeat = 0, totalMed = 0;
        let droppedPart = false;

        currentEnemies.forEach(e => {
            if (e.noLoot) return;
            
            // T√¨m trong b·∫£ng loot (ƒê√£ b·ªï sung Boss)
            let table = LOOT_TABLE[e.name] || { meat: 0.5, gen: 10, med: 0.0 };
            
            if (Math.random() < table.meat) totalMeat += 1;
            if (Math.random() < table.med) totalMed += 1;
            let gen = table.gen + rand(0, 5);

            // Bonus Trait
            e.traits.forEach(t => {
                if (t.name.includes("Huy·∫øt") || t.name.includes("M√°u")) { if (Math.random() < 0.5) totalMeat += 1; }
                if (t.name.includes("Tinh Th·ªÉ") || t.name.includes("G·ªó") || t.name.includes("S·∫Øt") || t.name.includes("Titan")) gen += 10;
                if (t.name.includes("H·∫°t Nh√¢n") || t.name.includes("V≈© Tr·ª•")) gen += 20;
            });

            totalGen += gen;
            if (e.isBoss) droppedPart = true;
        });

        player.genPoints += totalGen;
        player.items.meat += totalMeat;
        player.items.medkit += totalMed;

        if (player.regen > 0) player.hp = Math.min(player.maxHp, player.hp + player.regen);

        let msg = `Th·∫Øng! +${totalGen} Gen`;
        if (totalMeat > 0) msg += `, +${totalMeat} Th·ªãt`;
        if (totalMed > 0) msg += `, +${totalMed} Thu·ªëc`;
        log(msg, "new");

        if (droppedPart) { 
            player.parts++; 
            log(`üåü T√åM TH·∫§Y 1 LINH KI·ªÜN TH·ªúI GIAN! (${player.parts}/5)`, "boss"); 
            if (player.parts >= 5) {
                showModal("CHI·∫æN TH·∫ÆNG", "B·∫°n ƒë√£ s·ª≠a xong C·ªó M√°y Th·ªùi Gian v√† tr·ªü v·ªÅ nh√†!", true);
                return;
            } 
        }
        if (isBossFight) player.days++;
        setCombatMode(false);
        updateUI();
    }

    function rest() { if(player.items.meat>0){player.items.meat--;player.hp=Math.min(player.maxHp,player.hp+40);log("ƒÇn th·ªãt (+40 HP).","new");}else log("H·∫øt th·ªãt!","danger"); updateUI(); }
    function useMedkit() { if(player.items.medkit>0){player.items.medkit--;player.hp=Math.min(player.maxHp,player.hp+70);log("D√πng thu·ªëc (+70 HP).","new");}else log("H·∫øt thu·ªëc!","danger"); updateUI(); }
    function useTablecloth() { if(player.genPoints>=20){player.genPoints-=20;player.items.meat+=2;log("ƒê·ªïi 20 Gen -> 2 Th·ªãt.","new");}else log("C·∫ßn 20 Gen.","danger"); updateUI(); }
    function openEvo() {
        $("modal-title").innerText="S√öNG TI·∫æN H√ìA";
        $("modal-desc").innerText="";
        window.gunRolled = false;
        window.tempOpts = undefined;
        const tabHtml = `
            <div style="display:flex;gap:8px;margin-bottom:10px;">
                <button id="btn-evo-gun" class="evo-option" data-evo-tab="gun">üî´ B·∫Øn Gen (-50 Gen)</button>
                <button id="btn-surgery" class="evo-option" data-evo-tab="surgery">üß™ Tho√°i Ho√° (Ti√™u Tr·ª´ ƒê·∫∑c T√≠nh)</button>
            </div>
            <div id="evo-content"></div>
        `;
        $("modal-body").innerHTML = tabHtml;
        $("btn-close-modal").innerText="ƒê√≥ng";
        $("btn-close-modal").onclick=closeModal;
        $("modal-overlay").classList.remove("hidden");
        $("btn-evo-gun").disabled = false;
        const sbtn = $("btn-surgery"); 
        if (sbtn) sbtn.disabled = false;
    }
    function renderGunOptions(opts) {
        const currentTraitsSection = (() => {
            const traits = (player.traits || []).map(normTrait);
            if (!traits.length) {
                return `<details style="margin-bottom:10px;border:1px solid var(--border-color);border-radius:8px;background:#0b0f14;padding:10px;">
                    <summary style="cursor:pointer;color:#c9d1d9;font-weight:800;">üß¨ Gen hi·ªán c√≥ (0)</summary>
                    <div style="margin-top:8px;color:#8b949e;font-size:12px;">Ch∆∞a c√≥ ƒë·∫∑c t√≠nh n√†o.</div>
                </details>`;
            }
            const rows = traits.map(t => {
                const st = t.state === "ACTIVE" ? "Hi·ªán" : (t.state || "·∫®n");
                const tt = traitText(t);
                return `<div style="display:flex;gap:8px;align-items:flex-start;justify-content:space-between;border-top:1px dashed #30363d;padding:8px 0;">
                    <div style="min-width:0;">
                        <div style="color:#fff;font-weight:700;line-height:1.2;word-break:break-word;">${traitTagHTML(t)} <span style="color:#8b949e;font-size:12px;">[${t.part}] Lv.${t.level} (${st})</span></div>
                        <div style="margin-top:4px;color:#8b949e;font-size:12px;">${tt.base || ""}${tt.base && tt.inc ? " ‚Ä¢ " : ""}${tt.inc || ""}</div>
                        ${tt.total ? `<div style="margin-top:2px;color:#fff;font-size:12px;"><strong>${tt.total}</strong></div>` : ""}
                    </div>
                </div>`;
            }).join("");
            return `<details style="margin-bottom:10px;border:1px solid var(--border-color);border-radius:8px;background:#0b0f14;padding:10px;">
                <summary style="cursor:pointer;color:#c9d1d9;font-weight:800;">üß¨ Gen hi·ªán c√≥ (${traits.length})</summary>
                <div style="margin-top:8px;">${rows}</div>
                <div style="margin-top:8px;color:#8b949e;font-size:11px;">Tip: b·∫•m v√†o m≈©i t√™n ƒë·ªÉ thu g·ªçn khung n√†y khi mu·ªën t·∫≠p trung ch·ªçn.</div>
            </details>`;
        })();

        const html = opts.map((t,i)=>{
            const hasSame = !!findTrait(t.part, t.element);
            const occupied = isSlotOccupied(t.part);
            let title = "";
            let mode = "new"; // new | upgrade | replace
            let target = null;
            if (hasSame) {
                mode = "upgrade";
            } else if (occupied) {
                target = player.traits.find(x => x.part===t.part && x.state==="ACTIVE");
                if (target) {
                    title = ` title="S·∫Ω thay th·∫ø ${target.name} Lv.${target.level}"`;
                }
                mode = "replace";
            }
            normTrait(t);
            if (target) normalizeTraitColor(target);
            const badge =
                mode === "replace" ? `<span class="trait-badge trait-badge-replace">THAY TH·∫æ</span>` :
                mode === "upgrade" ? `<span class="trait-badge trait-badge-upgrade">UP C·∫§P</span>` :
                `<span class="trait-badge trait-badge-new">L·∫ÆP M·ªöI</span>`;

            const replaceLine = (mode === "replace" && target)
                ? `<div style="margin-top:6px;color:#8b949e;font-size:12px;">${traitTagHTML(t)} ‚Üí ${traitTagHTML(target)}</div>`
                : "";

            const style = mode === "replace" ? `style="border-color:${t.color}; background:${t.color}33; color:#fff;"` : `style="border-color:${t.color}; background:${t.color}33; color:#fff;"`;
            const tt = traitText(t);
            return `<button class="evo-option" data-mode="${mode}" data-evo-pick="${i}" ${style}${title}>
                <strong>${t.name}</strong> ${badge}<br>
                <small>${t.desc || ""}</small>
                ${tt.base ? `<div style="margin-top:6px;color:#8b949e;font-size:12px;">${tt.base}</div>` : ""}
                ${tt.inc ? `<div style="margin-top:6px;color:#8b949e;font-size:12px;">${tt.inc}</div>` : ""}
                ${tt.total ? `<div style="margin-top:2px;color:#fff;font-size:12px;"><strong>${tt.total}</strong></div>` : ""}
                ${t.passive?`<br><span style="color:#fff">‚òÖ ${t.passive}</span>`:''}
                ${replaceLine}
            </button>`;
        }).join("");
        $("evo-content").innerHTML = currentTraitsSection + html;
    }
    function openEvoGun() {
        if (window.gunRolled) { 
            renderGunOptions(window.tempOpts || []); 
            const btn = $("btn-evo-gun"); 
            if (btn) btn.disabled = true; 
            return; 
        }
        if(player.genPoints<50){ 
            $("evo-content").innerHTML = `<div>Thi·∫øu Gen (c·∫ßn 50).</div>`; 
            return; 
        }
        player.genPoints -= 50;
        updateUI();
        let opts=[]; for(let i=0;i<3;i++)opts.push(generateSynergyTrait());
        window.tempOpts=opts;
        window.gunRolled = true;
        renderGunOptions(opts);
        const btn = $("btn-evo-gun"); 
        if (btn) btn.disabled = true;
        const sbtn = $("btn-surgery"); 
        if (sbtn) sbtn.disabled = true;
    }
    function openSurgery() {
        if (player.traits.length===0) { $("evo-content").innerHTML = `<div>Ch∆∞a c√≥ gen.</div>`; return; }
        let html = player.traits.map(normTrait).map((t,idx)=>{
            const st = t.state==="ACTIVE"?"Hi·ªán":"·∫®n";
            return `<div style="border:1px solid var(--border-color);padding:8px;margin-bottom:6px;border-radius:6px;background:#0b0f14;">
                <div>${traitTagHTML(t)} <strong>[${t.part}] Lv.${t.level} (${st})</strong></div>
                <small>${t.desc}</small>
                <button class="evo-option" data-cut-trait="${idx}">Ti√™u Tr·ª´ ƒê·∫∑c T√≠nh</button>
            </div>`;
        }).join("");
        $("evo-content").innerHTML = html;
    }
    function removeTraitByIndex(idx) {
        let t = player.traits[idx];
        ensureTraitScalingFields(t);
        let total = traitTotalVal(t);
        if (t.type === "HP") { player.maxHp -= total; player.hp = Math.min(player.hp, player.maxHp); }
        if (t.type === "ATK") player.atk -= total;
        if (t.type === "DEF") player.def -= total;
        if (t.type === "SPD") player.spd -= total;
        if (t.type === "REGEN") player.regen -= total;
        if (t.state==="ACTIVE") player.slots[t.part]=false;
        player.traits.splice(idx,1);
        updateUI();
    }
    function cutTrait(idx) {
        removeTraitByIndex(idx);
        openSurgery();
    }
    function closeModal() { $("modal-overlay").classList.add("hidden"); }
    function doEvolve(i) {
        let t=window.tempOpts[i];
        // Kh√¥ng ch·∫•p nh·∫≠n trait kh√¥ng c√≥ element (d·ªØ li·ªáu l·ªói)
        if (!t || !t.element) {
            log("L·ªói Gen: ƒë·∫∑c t√≠nh kh√¥ng c√≥ element (kh√¥ng th·ªÉ l·∫Øp).", "danger");
            showModal("L·ªñI GEN", "ƒê·∫∑c t√≠nh ƒë∆∞·ª£c t·∫°o ra b·ªã thi·∫øu element. H√£y th·ª≠ b·∫Øn l·∫°i.", false);
            return;
        }
        const existing = findTrait(t.part, t.element);
        if (existing) {
            ensureTraitScalingFields(existing);
            existing.level += 1;
            const inc = rollUpgradeIncrement(existing);
            existing.val = inc; // val gi·ªù l√† "tƒÉng g·∫ßn nh·∫•t" (bi·∫øn ƒë·ªông theo l·∫ßn up)
            existing.totalVal = Number(existing.totalVal ?? 0) + inc;
            applyTraitStats(existing, 1, inc);
            if (existing.level >= 5) {
                existing.state = "FUSED";
                player.slots[existing.part] = false;
            }
            log(`Ti·∫øn h√≥a: ${existing.name} Lv.${existing.level} (+${inc}, T·ªïng: ${traitTotalVal(existing)})`,"new");
            updateUI();
            closeModal();
            return;
        }
        if (isSlotOccupied(t.part)) {
            const idx = player.traits.findIndex(x => x.part===t.part && x.state==="ACTIVE");
            if (idx !== -1) {
                log(`Thay th·∫ø: Ti√™u tr·ª´ ${player.traits[idx].name} v√† l·∫Øp ${t.name}.`,"danger");
                removeTraitByIndex(idx);
            }
        }
        // Trait m·ªõi: kh·ªüi t·∫°o field ƒë·ªÉ h·ªó tr·ª£ upgrade random sau n√†y
        ensureTraitScalingFields(t);
        player.traits.push(t);
        player.slots[t.part]=true;
        applyTraitStats(t,1);
        log(`Ti·∫øn h√≥a: ${t.name}`,"new");
        updateUI();
        closeModal();
    }

    function showModal(title, msg, reload=false, customBody="") {
        $("modal-title").innerText = title;
        $("modal-desc").innerText = msg;
        $("modal-body").innerHTML = customBody;
        $("btn-close-modal").innerText = reload ? "Ch∆°i l·∫°i" : "ƒê√≥ng";
        $("btn-close-modal").onclick = reload ? () => location.reload() : closeModal;
        $("modal-overlay").classList.remove("hidden");
    }

    // 1 listener cho c√°c thao t√°c trong modal (evo pick / surgery / combat evo gun)
    $("modal-overlay").addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn || btn.disabled) return;

        // Combat evo gun choice
        if (btn.dataset.cgev) {
            const targetId = Number(btn.dataset.cgev);
            const mode = btn.dataset.mode;
            return combatEvoGunChoose(targetId, mode);
        }

        // Evo tabs
        const tabMap = { gun: openEvoGun, surgery: openSurgery };
        const tab = btn.dataset.evoTab;
        if (tab && tabMap[tab]) return tabMap[tab]();

        // Pick evolve option
        if (btn.dataset.evoPick !== undefined) {
            const idx = Number(btn.dataset.evoPick);
            if (Number.isFinite(idx)) return doEvolve(idx);
        }

        // Cut trait in surgery
        if (btn.dataset.cutTrait !== undefined) {
            const idx = Number(btn.dataset.cutTrait);
            if (Number.isFinite(idx)) return cutTrait(idx);
        }
    });

    updateUI();

    //ƒë·ªìng minh, cƒÉn c·ª©, map
</script>

</body>
</html>
